import { NextResponse } from "next/server.js";
import picomatch from "picomatch";
import { resolveAuthConfig } from "../nextjs/config.js";
import { loggers } from "../lib/logger.js";
import { ServerAuthenticationResolver } from "../server/ServerAuthenticationResolver.js";
const logger = loggers.nextjs.middleware;
/**
 * CookieStorage implementation for NextJS middleware context that works with NextRequest
 */
class NextjsReadOnlyRequestCookieStorage {
    request;
    constructor(request) {
        this.request = request;
    }
    async get(key) {
        return this.request.cookies.get(key)?.value || null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async set(key, value) {
        // In middleware, we can only set cookies via response objects
        // This method can't be used directly in middleware
        logger.error("Cannot set cookies directly in middleware");
        throw new Error("Cannot set cookies directly in middleware");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async delete(key) {
        // In middleware, we can only delete cookies via response objects
        // This method can't be used directly in middleware
        logger.error("Cannot delete cookies directly in middleware");
        throw new Error("Cannot delete cookies directly in middleware");
    }
}
// Matches globs:
// Examples:
// /user
// /user/*
// /user/**/info
const matchGlob = (pathname, globPattern) => {
    const matches = picomatch(globPattern);
    return matches(pathname);
};
// Matches globs:
// Examples:
// /user
// /user/*
// /user/**/info
const matchesGlobs = (pathname, patterns) => patterns.some((pattern) => {
    if (!pattern)
        return false;
    return matchGlob(pathname, pattern);
});
/**
 * use a ServerAuthenticationResolver to validate the existing session
 * using NextJS cookie storage
 * @param authConfigWithDefaults
 * @param request NextRequest object from middleware
 * @returns {Promise<SessionData>}
 */
export const validateAuthTokensIfPresent = async (authConfigWithDefaults, request) => {
    try {
        // TODO: evaluate a more performant way to validate tokens
        // than having to call and verify the JWT tokens on every request
        const storage = new NextjsReadOnlyRequestCookieStorage(request);
        const authSessionService = await ServerAuthenticationResolver.build({
            ...authConfigWithDefaults,
            redirectUrl: authConfigWithDefaults.callbackUrl,
        }, storage);
        // validate the existing session but don't auto-refresh as we can't set cookies in middleware
        const existingSession = await authSessionService.validateExistingSession(false);
        return existingSession;
    }
    catch (error) {
        logger.error("Error validating tokens", error);
        return { authenticated: false };
    }
};
// internal - used by all exported functions
/**
 * Core authentication middleware logic.
 *
 * Flow:
 * 1. Always validate tokens first to determine authentication state
 * 2. Skip protection for Civic Auth system URLs and excluded paths
 * 3. For unauthenticated users on protected routes:
 *    - If refresh token exists: redirect to refresh endpoint
 *    - If expired tokens exist: redirect to logout callback to clear them
 *    - If on login URL: allow access (prevents redirect loops)
 *    - Otherwise: redirect to login
 * 4. Allow authenticated users to continue
 */
const applyAuth = async (authConfig, request) => {
    const authConfigWithDefaults = resolveAuthConfig(authConfig);
    // Always validate tokens first to determine authentication state
    const session = await validateAuthTokensIfPresent(authConfigWithDefaults, request);
    logger.debug("applyAuth session data:", session);
    // Skip auth protection for Civic Auth system URLs (callback, challenge, logout)
    if ([
        authConfigWithDefaults.callbackUrl,
        authConfigWithDefaults.challengeUrl,
        authConfigWithDefaults.logoutCallbackUrl,
        authConfigWithDefaults.logoutUrl,
    ].includes(request.nextUrl.pathname) &&
        request.method === "GET") {
        logger.debug("→ Skipping auth check - this a URL defined in authConfig", request.nextUrl.pathname);
        return undefined;
    }
    // Skip auth protection for paths not in include patterns (except loginUrl)
    if (request.nextUrl.pathname !== authConfigWithDefaults.loginUrl &&
        !matchesGlobs(request.nextUrl.pathname, authConfigWithDefaults.include)) {
        logger.debug("→ Skipping auth check - path not in include patterns", request.nextUrl.pathname);
        return undefined;
    }
    // Skip auth protection for paths in exclude patterns (except loginUrl)
    if (request.nextUrl.pathname !== authConfigWithDefaults.loginUrl &&
        matchesGlobs(request.nextUrl.pathname, authConfigWithDefaults.exclude)) {
        logger.debug("→ Skipping auth check - path in exclude patterns", request.nextUrl.pathname);
        return undefined;
    }
    // Handle unauthenticated users on protected routes
    if (!session.authenticated) {
        const targetUrl = request.nextUrl.origin + request.nextUrl.pathname;
        // Avoid redirect loops by checking if already in a redirect flow
        if (!request.nextUrl.searchParams.has("targetUrl")) {
            // Attempt session rehydration if refresh token exists
            if (session.refreshToken) {
                const refreshUrl = new URL(authConfigWithDefaults.refreshUrl, request.nextUrl.origin);
                refreshUrl.searchParams.set("targetUrl", targetUrl);
                const redirectUrl = `${refreshUrl.toString()}`;
                logger.debug(`→ Refresh token found - redirecting to "${redirectUrl}"`);
                return NextResponse.redirect(redirectUrl);
            }
            // Clear expired/invalid tokens if they exist without refresh token
            if (session.accessToken || session.idToken) {
                const clearBadTokensUrl = new URL(authConfigWithDefaults.logoutCallbackUrl, request.nextUrl.origin);
                clearBadTokensUrl.searchParams.set("targetUrl", targetUrl);
                logger.debug(`→ Invalid tokens found without refresh - clearing via "${clearBadTokensUrl}"`);
                return NextResponse.redirect(clearBadTokensUrl);
            }
        }
        // Allow access to login page to prevent redirect loops
        if (request.nextUrl.pathname === authConfigWithDefaults.loginUrl) {
            logger.debug(`→ Allowing access to login page for unauthenticated user`);
            return undefined;
        }
        // Final fallback: redirect to login
        const loginUrl = new URL(authConfigWithDefaults.loginUrl, request.nextUrl.origin);
        const redirectUrl = `${loginUrl.toString()}`;
        logger.debug(`→ No valid tokens found - redirecting to login "${redirectUrl}"`);
        return NextResponse.redirect(redirectUrl);
    }
    logger.debug("→ Auth check passed");
    return undefined;
};
/**
 *
 * Use this when auth is the only middleware you need.
 * Usage:
 *
 * export default authMiddleware({ loginUrl = '/login' }); // or just authMiddleware();
 *
 */
export const authMiddleware = (authConfig = {}) => async (request) => {
    const response = await applyAuth(authConfig, request);
    if (response)
        return response;
    // NextJS doesn't do middleware chaining yet, so this does not mean
    // "call the next middleware" - it means "continue to the route handler"
    return NextResponse.next();
};
/**
 * Usage:
 *
 * export default withAuth(async (request) => {
 *    logger.debug('my middleware');
 *    return NextResponse.next();
 *  })
 */
// use this when you have your own middleware to chain
export function withAuth(middleware) {
    return auth()(middleware);
}
/**
 * Use this when you want to configure the middleware here (an alternative is to do it in the next.config file)
 *
 * Usage:
 *
 * export default auth(authConfig: AuthConfig ) => {
 *    logger.debug('my middleware');
 *    return NextResponse.next();
 *  })
 *
 */
export function auth(authConfig = {}) {
    return (middleware) => {
        return async (request) => {
            const response = await applyAuth(authConfig, request);
            if (response)
                return response;
            return middleware(request);
        };
    };
}
//# sourceMappingURL=middleware.js.map