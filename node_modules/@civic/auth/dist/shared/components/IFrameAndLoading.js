import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "@emotion/react/jsx-runtime";
import React, { useEffect, useState } from "react";
import { useIframe } from "../hooks/useIframe.js";
import { useIsInIframe } from "../hooks/useIsInIframe.js";
import { CivicAuthIframeContainer } from "./CivicAuthIframeContainer.js";
import { BlockDisplay } from "./BlockDisplay.js";
import { LoadingIcon } from "./LoadingIcon.js";
import { CivicAuthLogoutIframeContainer } from "./CivicAuthLogoutIframeContainer.js";
import { useSession } from "../hooks/useSession.js";
import { useAuthStatus } from "../providers/AuthStatusContext.js";
import { AuthStatus } from "../../types.js";
const IFrameAndLoading = ({ error, showIframeOnLogout = false, }) => {
    const isInIframe = useIsInIframe();
    const [logoutIframeLoading, setLogoutIframeLoading] = useState(true);
    const { renderIframe, iframeIsVisible, setIframeIsVisible, logoutIframeIsVisible, } = useIframe();
    const { authStatus } = useAuthStatus();
    const session = useSession();
    // we show a loading overlay to block the display for the user
    // as the page that loads within the iframe will be the actual customer
    // login page just after authenticatino, which shouldn't be shown to the user during login
    // there's a small period where we're resolving the session and the iframe is showing
    const showLoadingOverlay = isInIframe;
    useEffect(() => {
        const handleErrorMessage = (event) => {
            const thisURL = new URL(window.location.href);
            if (!(event.origin.endsWith("civic.com") || thisURL.hostname === "localhost")) {
                return;
            }
            // The login app has thrown an error, so we need to show the logout iframe
            if (event.data?.source === "civicloginApp" &&
                event.data?.type === "auth_error") {
                setLogoutIframeLoading(false);
                return;
            }
            setLogoutIframeLoading(true);
        };
        window.addEventListener("message", handleErrorMessage);
        return () => window.removeEventListener("message", handleErrorMessage);
    }, []);
    const [iframeShouldRender, setIframeShouldRender] = useState(renderIframe);
    useEffect(() => {
        // We can't remove the iframe from the DOM immediately on authentication,
        // because it needs a short window to render a special 'TOKEN_EXCHANGE_SUCCESS' message
        // which the parent needs to detect in order to redirect to the loginSuccessUrl if any.
        // So we wait 500ms to allow that to happen before removing the iframe.
        if (session.data?.authenticated) {
            setTimeout(() => {
                return setIframeShouldRender(false);
            }, 500);
        }
    }, [session.data?.authenticated]);
    /**
     * This useEffect resets the iframeShouldRender state when the authStatus changes. We need it
     * as the iframeShouldRender state is set to false when the user is authenticated, but it needs to be reset
     */
    useEffect(() => {
        if (authStatus !== AuthStatus.AUTHENTICATED) {
            setIframeShouldRender(renderIframe);
        }
    }, [authStatus, renderIframe, iframeIsVisible]);
    return (_jsxs(_Fragment, { children: [iframeShouldRender && (_jsx("div", { style: iframeIsVisible ? { display: "block" } : { display: "none" }, children: _jsx(CivicAuthIframeContainer, { onClose: () => setIframeIsVisible(false) }) })), _jsx("div", { style: showIframeOnLogout && logoutIframeIsVisible
                    ? { display: "block" }
                    : { display: "none" }, children: _jsx(CivicAuthLogoutIframeContainer, { isLoading: logoutIframeLoading }) }), error && (_jsx(BlockDisplay, { children: _jsxs("div", { children: ["Error: ", error?.message] }) })), showLoadingOverlay && !error && (_jsx(BlockDisplay, { children: _jsx(LoadingIcon, {}) }))] }));
};
export { IFrameAndLoading };
//# sourceMappingURL=IFrameAndLoading.js.map