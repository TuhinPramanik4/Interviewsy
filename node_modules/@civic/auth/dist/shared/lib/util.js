import { AUTH_SERVER_LEGACY_SESSION, AUTH_SERVER_SESSION, OAuthTokenTypes, } from "./types.js";
import { OAuth2Client } from "oslo/oauth2";
import { getIssuerVariations, getOauthEndpoints } from "../../lib/oauth.js";
import * as jose from "jose";
import { withoutUndefined } from "../../utils.js";
import { GenericUserSession } from "../../shared/lib/UserSession.js";
import { decodeJwt } from "jose";
import { AUTOREFRESH_TIMEOUT_NAME, LOGOUT_STATE, REFRESH_IN_PROGRESS, } from "../../constants.js";
import { loggers } from "../../lib/logger.js";
const logger = loggers.services.validation;
/**
 * Given a PKCE code verifier, derive the code challenge using SHA
 */
export async function deriveCodeChallenge(codeVerifier, method = "S256") {
    if (method === "Plain") {
        console.warn("Using insecure plain code challenge method");
        return codeVerifier;
    }
    const encoder = new TextEncoder();
    const data = encoder.encode(codeVerifier);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/, "");
}
export async function getEndpointsWithOverrides(oauthServer, endpointOverrides = {}) {
    const endpoints = await getOauthEndpoints(oauthServer);
    return {
        ...endpoints,
        ...endpointOverrides,
    };
}
export async function generateOauthLoginUrl(config) {
    const endpoints = await getEndpointsWithOverrides(config.oauthServer, config.endpointOverrides);
    const oauth2Client = buildOauth2Client(config.clientId, config.redirectUrl, endpoints);
    const oAuthUrl = await oauth2Client.createAuthorizationURL({
        state: config.state,
        scopes: config.scopes,
    });
    // Only add PKCE parameters if a pkceConsumer is provided
    if (config.pkceConsumer) {
        const challenge = await config.pkceConsumer.getCodeChallenge();
        // The OAuth2 client supports PKCE, but does not allow passing in a code challenge from some other source
        // It only allows passing in a code verifier which it then hashes itself.
        oAuthUrl.searchParams.append("code_challenge", challenge);
        oAuthUrl.searchParams.append("code_challenge_method", "S256");
    }
    if (config.nonce) {
        // nonce isn't supported by oslo, so we add it manually
        oAuthUrl.searchParams.append("nonce", config.nonce);
    }
    // Required by the auth server for offline_access scope
    oAuthUrl.searchParams.append("prompt", "consent");
    return oAuthUrl;
}
export async function generateOauthLogoutUrl(config) {
    const endpoints = await getEndpointsWithOverrides(config.oauthServer, config.endpointOverrides);
    const endSessionUrl = new URL(endpoints.endsession);
    endSessionUrl.searchParams.append("client_id", config.clientId);
    endSessionUrl.searchParams.append("id_token_hint", config.idToken);
    endSessionUrl.searchParams.append("state", config.state);
    endSessionUrl.searchParams.append("post_logout_redirect_uri", config.redirectUrl);
    return endSessionUrl;
}
export function buildOauth2Client(clientId, redirectUri, endpoints) {
    return new OAuth2Client(clientId, endpoints.auth, endpoints.token, {
        redirectURI: redirectUri,
    });
}
export async function exchangeTokens(code, state, pkceProducer, oauth2Client, oauthServer, endpoints, clientSecret) {
    // Get code verifier if using PKCE
    const codeVerifier = pkceProducer
        ? await pkceProducer.getCodeVerifier()
        : null;
    // Ensure at least one authentication method is provided
    if (!codeVerifier && !clientSecret) {
        throw new Error("Either PKCE code verifier or client secret must be provided");
    }
    // Build options for validateAuthorizationCode
    const validationOptions = {};
    if (codeVerifier) {
        validationOptions.codeVerifier = codeVerifier;
    }
    if (clientSecret) {
        validationOptions.credentials = clientSecret;
        validationOptions.authenticateWith = "request_body"; // Use client_secret_post method
    }
    const tokens = (await oauth2Client.validateAuthorizationCode(code, validationOptions));
    // Validate relevant tokens
    try {
        await validateOauth2Tokens(tokens, endpoints.jwks, oauth2Client, oauthServer);
    }
    catch (error) {
        console.error("tokenExchange error", { error, tokens });
        throw new Error(`OIDC tokens validation failed: ${error.message}`);
    }
    return tokens;
}
/**
 * Calculates the maxAge values for access and refresh token cookies
 * based on the TTL values in the access token
 *
 * maxAge needs to be in seconds from now until expiration
 *
 * @param tokens OIDC tokens response containing the access token
 * @returns Object with accessTokenMaxAge and refreshTokenMaxAge in seconds
 */
export const getCookiesMaxAge = (tokens) => {
    const DEFAULT_TTL = 60 * 60; // 1 hour default
    let idTokenMaxAge = DEFAULT_TTL;
    let accessTokenMaxAge = DEFAULT_TTL;
    // The ID token takes priority, as it represents the OIDC session
    if (tokens.id_token) {
        // If no access token exists, try to get expiration from ID token
        const parsedIdToken = decodeJwt(tokens.id_token);
        if (parsedIdToken?.exp) {
            const now = Math.floor(Date.now() / 1000);
            idTokenMaxAge = parsedIdToken.exp - now;
        }
    }
    if (tokens.access_token) {
        // Get access token TTL from the token if it exists
        const parsedAccessToken = decodeJwt(tokens.access_token);
        accessTokenMaxAge =
            Number(parsedAccessToken?.accessTokenTTL) || DEFAULT_TTL;
        // If access token has exp claim, use that directly
        if (parsedAccessToken?.exp) {
            const now = Math.floor(Date.now() / 1000);
            accessTokenMaxAge = parsedAccessToken.exp - now;
        }
    }
    return {
        accessTokenMaxAge,
        idTokenMaxAge,
    };
};
export async function setOidcSessionExpiresAt(storage, tokens) {
    const now = Math.floor(Date.now() / 1000);
    const { idTokenMaxAge } = getCookiesMaxAge(tokens);
    // The OIDC session expiry is linked to the ID token expiry, since this is primarily an OIDC client.
    await storage.set(OAuthTokenTypes.OIDC_SESSION_EXPIRES_AT, (idTokenMaxAge + now).toString());
}
export async function storeTokens(storage, tokens) {
    // ID token is the primary token and must always be stored
    await storage.set(OAuthTokenTypes.ID_TOKEN, tokens.id_token);
    // Only store access token if it exists (no longer required)
    if (tokens.access_token) {
        await storage.set(OAuthTokenTypes.ACCESS_TOKEN, tokens.access_token);
    }
    // Store refresh token if it exists
    if (tokens.refresh_token) {
        await storage.set(OAuthTokenTypes.REFRESH_TOKEN, tokens.refresh_token);
    }
    // Still set access token expiration even if no access token
    // (will get expiration from ID token in this case)
    await setOidcSessionExpiresAt(storage, tokens);
}
/**
 * Stores tokens in server-side cookies with appropriate expiration times
 * Uses TTL values from the tokens to set cookie maxAge values
 * Refresh token is set with no expiry (session cookie)
 */
export async function storeServerTokens(storage, tokens) {
    // Get maxAge values based on token TTLs (refresh token TTL will be undefined)
    const now = Math.floor(Date.now() / 1000);
    const { idTokenMaxAge, accessTokenMaxAge } = getCookiesMaxAge(tokens);
    // The OIDC session expiry is linked to the ID token expiry, since this is primarily an OIDC client.
    const oidcSessionExpiresAt = now + idTokenMaxAge;
    const cookieStorage = storage;
    // Apply maxAge to cookie options
    const accessTokenCookieOptions = {
        maxAge: accessTokenMaxAge,
    };
    const refreshTokenCookieOptions = {
        maxAge: undefined, // This is a session cookie, does not expire.
    };
    // ID token is always stored (primary authentication token)
    await cookieStorage.set(OAuthTokenTypes.ID_TOKEN, tokens.id_token, {
        maxAge: idTokenMaxAge,
    });
    // Access token is optional - only set if it exists
    if (tokens.access_token) {
        await cookieStorage.set(OAuthTokenTypes.ACCESS_TOKEN, tokens.access_token, accessTokenCookieOptions);
    }
    // Set refresh token if present as a session cookie (no expiry)
    if (tokens.refresh_token) {
        await cookieStorage.set(OAuthTokenTypes.REFRESH_TOKEN, tokens.refresh_token, refreshTokenCookieOptions);
    }
    // Still store the access token expiration timestamp even if no access token
    await storage.set(OAuthTokenTypes.OIDC_SESSION_EXPIRES_AT, oidcSessionExpiresAt.toString(), {
        // This is primarily an OIDC client, so we use the ID token max age for the session timeout / refresh scheduling.
        maxAge: idTokenMaxAge,
    });
    logger.debug("storeServerTokens", {
        oidcSessionExpiresAt,
        refreshTokenMaxAge: "undefined (session cookie)",
        idTokenMaxAge,
        hasAccessToken: !!tokens.access_token,
    });
}
export async function clearTokens(storage) {
    // clear all local storage keys related to OAuth and CivicAuth SDK
    const clearOAuthPromises = [
        ...Object.values(OAuthTokenTypes),
        REFRESH_IN_PROGRESS,
        AUTOREFRESH_TIMEOUT_NAME,
        LOGOUT_STATE,
    ].map(async (key) => {
        await storage.delete(key);
    });
    await Promise.all([...clearOAuthPromises]);
}
export async function clearAuthServerSession(storage) {
    await storage.delete(AUTH_SERVER_SESSION);
    await storage.delete(AUTH_SERVER_LEGACY_SESSION);
}
export async function clearUser(storage) {
    const userSession = new GenericUserSession(storage);
    await userSession.clear();
}
export async function retrieveTokens(storage) {
    const idToken = await storage.get(OAuthTokenTypes.ID_TOKEN);
    const accessToken = await storage.get(OAuthTokenTypes.ACCESS_TOKEN);
    const refreshToken = await storage.get(OAuthTokenTypes.REFRESH_TOKEN);
    const oidcSessionExpiresAt = await storage.get(OAuthTokenTypes.OIDC_SESSION_EXPIRES_AT);
    return {
        id_token: idToken ?? undefined,
        access_token: accessToken ?? undefined,
        refresh_token: refreshToken ?? undefined,
        oidc_session_expires_at: oidcSessionExpiresAt !== null
            ? parseInt(oidcSessionExpiresAt, 10)
            : undefined, // Convert string to number
    };
}
export async function retrieveOidcSessionExpiredAt(storage) {
    const value = await storage.get(OAuthTokenTypes.OIDC_SESSION_EXPIRES_AT);
    if (!value) {
        return null;
    }
    const expiresAt = Number(value);
    return isNaN(expiresAt) ? null : expiresAt;
}
// Single JWKS instance that persists for the lifetime of the SDK session
let cachedJWKS = null;
let cachedJwksUrl = null;
export async function validateOauth2Tokens(tokens, jwksEndpoint, oauth2Client, issuer) {
    // Only create a new JWKS instance if one doesn't exist yet
    if (!cachedJWKS || cachedJwksUrl !== jwksEndpoint) {
        cachedJWKS = jose.createRemoteJWKSet(new URL(jwksEndpoint));
        cachedJwksUrl = jwksEndpoint;
    }
    // Validate the ID token - this is now the primary token for authentication
    const idTokenResponse = await jose.jwtVerify(tokens.id_token, cachedJWKS, {
        issuer: getIssuerVariations(issuer),
        audience: oauth2Client.clientId,
    });
    // Only validate the access token if it exists, but if present it must be valid
    let accessTokenPayload;
    if (tokens.access_token) {
        const accessTokenResponse = await jose.jwtVerify(tokens.access_token, cachedJWKS, {
            issuer: getIssuerVariations(issuer),
        });
        accessTokenPayload = accessTokenResponse.payload;
    }
    return withoutUndefined({
        id_token: idTokenResponse.payload,
        access_token: accessTokenPayload,
        ...(tokens?.refresh_token ? { refresh_token: tokens.refresh_token } : {}),
    });
}
//# sourceMappingURL=util.js.map