import { BrowserAuthenticationInitiator } from "../../services/AuthenticationService.js";
import { BrowserPublicClientPKCEProducer } from "../../services/PKCE.js";
import { useCivicAuthConfig } from "../../shared/hooks/useCivicAuthConfig.js";
import { AuthStatus, } from "../../types.js";
import { useIframe } from "../../shared/hooks/useIframe.js";
import { useCallback, useEffect, useMemo, useRef } from "react";
import { PopupError } from "../../services/types.js";
import { useSession } from "./useSession.js";
import { LocalStorageAdapter } from "../../browser/storage.js";
import { clearTokens, clearUser } from "../lib/util.js";
import { useLocalStorage } from "usehooks-ts";
import { LOGOUT_STATE } from "../../constants.js";
import { useAuthStatus } from "../../shared/providers/AuthStatusContext.js";
const SIGN_IN_TIMEOUT_MS = 9 * 60 * 1000; // 9 minutes in milliseconds
/**
 * Hook to manage authentication flow.
 */
const useSignIn = ({ pkceConsumer, preSignOut, postSignOut, displayMode } = {
    displayMode: "iframe",
}) => {
    // Config and external state
    const civicAuthConfig = useCivicAuthConfig();
    const { iframeRef, logoutIframeRef, setIframeIsVisible, setLogoutIframeIsVisible, iframeAborted, setIframeAborted, } = useIframe();
    const { data: session } = useSession();
    const { authStatus, setAuthStatus } = useAuthStatus();
    const [, setDesignOption] = useLocalStorage(`loginAppDesign`, { colorMode: "auto" });
    // Internal state tracking
    const timeoutRef = useRef(null);
    const authStatusRef = useRef(AuthStatus.UNAUTHENTICATED);
    const isSigningInRef = useRef(false);
    // Promise handling
    const signInPromiseRef = useRef();
    const signInResolveRef = useRef(null);
    const signInRejectRef = useRef(null);
    // Event handlers
    const handlersRef = useRef({
        handleSignInComplete: null,
        handleSignInError: null,
    });
    // Helper to resolve/reject sign-in promise with cleanup
    const resolveSignInPromise = useCallback(() => {
        if (signInResolveRef.current) {
            setAuthStatus(AuthStatus.AUTHENTICATED);
            authStatusRef.current = AuthStatus.AUTHENTICATED;
            isSigningInRef.current = false;
            signInResolveRef.current();
            // Clean up after resolving
            signInResolveRef.current = null;
            signInRejectRef.current = null;
            signInPromiseRef.current = undefined;
            if (timeoutRef.current !== null) {
                window.clearTimeout(timeoutRef.current);
                timeoutRef.current = null;
            }
        }
    }, [setAuthStatus]);
    const rejectSignInPromise = useCallback((error, newStatus = AuthStatus.ERROR) => {
        if (signInRejectRef.current) {
            signInRejectRef.current(error);
            // Clean up after rejecting
            signInResolveRef.current = null;
            signInRejectRef.current = null;
            signInPromiseRef.current = undefined;
            isSigningInRef.current = false;
            setAuthStatus(newStatus);
            if (timeoutRef.current !== null) {
                window.clearTimeout(timeoutRef.current);
                timeoutRef.current = null;
            }
        }
    }, [setAuthStatus]);
    // Create authentication initiator
    const authInitiator = useMemo(() => {
        if (!civicAuthConfig)
            return null;
        const { clientId, redirectUrl, logoutUrl, loginSuccessUrl, logoutRedirectUrl, nonce, oauthServer, endpoints, scopes, } = civicAuthConfig;
        return new BrowserAuthenticationInitiator({
            pkceConsumer: pkceConsumer || new BrowserPublicClientPKCEProducer(),
            clientId,
            redirectUrl,
            loginSuccessUrl,
            logoutUrl,
            logoutRedirectUrl,
            scopes,
            displayMode,
            oauthServer,
            endpointOverrides: endpoints,
            nonce,
        }, setDesignOption);
    }, [civicAuthConfig, displayMode, pkceConsumer, setDesignOption]);
    // Cleanup resources when component unmounts
    useEffect(() => {
        return () => {
            if (authInitiator) {
                authInitiator.cleanup();
            }
            if (timeoutRef.current !== null) {
                window.clearTimeout(timeoutRef.current);
                timeoutRef.current = null;
            }
        };
    }, [authInitiator]);
    // Handle logout state cleanup
    useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const state = params.get("state");
        const localStorage = new LocalStorageAdapter();
        localStorage.get(LOGOUT_STATE).then((storedLogoutState) => {
            if (state && state === storedLogoutState) {
                // Clear storage
                clearTokens(localStorage);
                clearUser(localStorage);
                LocalStorageAdapter.emitter.emit("signOut");
                // Clean up storage and URL
                sessionStorage.removeItem(LOGOUT_STATE);
                const cleanUrl = window.location.href.split("?")[0];
                window.history.replaceState({}, document.title, cleanUrl);
            }
        });
    }, []);
    // Main sign-in logic
    const startSignIn = useCallback(async () => {
        if (!authInitiator)
            return;
        // Create the promise and store its handlers
        const promise = new Promise((resolve, reject) => {
            signInResolveRef.current = resolve;
            signInRejectRef.current = reject;
        });
        signInPromiseRef.current = promise;
        // Check if sign-in is already in progress using the ref, if so, return signIn promise
        if (isSigningInRef.current) {
            return promise;
        }
        // State machine for sign-in flow
        switch (authStatus) {
            case AuthStatus.AUTHENTICATED:
                return Promise.resolve();
            case AuthStatus.UNAUTHENTICATED:
            case AuthStatus.ERROR:
                break;
            case AuthStatus.AUTHENTICATING:
                // if we're already authenticating, return the existing promise
                return promise;
            default:
                return Promise.reject(new Error(`Invalid state for sign-in: ${authStatus}`));
        }
        // Set signing in flag first
        isSigningInRef.current = true;
        // Clear any existing timeout
        if (timeoutRef.current !== null) {
            window.clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
        }
        try {
            // Set authenticating status before any async operations
            setAuthStatus(AuthStatus.AUTHENTICATING);
            authStatusRef.current = AuthStatus.AUTHENTICATING;
            authInitiator.setDisplayMode(displayMode);
            // Set a timeout to reject the promise if authentication takes too long
            timeoutRef.current = window.setTimeout(() => {
                if (authStatusRef.current === AuthStatus.AUTHENTICATING) {
                    rejectSignInPromise(new Error("Sign-in timeout"));
                }
            }, SIGN_IN_TIMEOUT_MS);
            // Start the authentication process
            const useIframeRef = iframeRef?.current || null;
            await authInitiator.signIn(useIframeRef);
        }
        catch (error) {
            // Reset the signing in flag on error
            isSigningInRef.current = false;
            if (error instanceof PopupError) {
                // Fallback to redirect if popup fails
                setIframeIsVisible(false);
                authInitiator.cleanup();
                authInitiator.setDisplayMode("redirect");
                try {
                    // Call signIn again with redirect mode
                    await authInitiator.signIn(iframeRef?.current || null);
                }
                catch (retryError) {
                    console.error("[useSignIn] Redirect sign-in initiation error", retryError);
                    rejectSignInPromise(retryError instanceof Error
                        ? retryError
                        : new Error(String(retryError)));
                    return promise;
                }
            }
            else {
                rejectSignInPromise(error instanceof Error ? error : new Error(String(error)));
                return promise;
            }
        }
        return promise;
    }, [
        authInitiator,
        displayMode,
        iframeRef,
        setIframeIsVisible,
        authStatus,
        setAuthStatus,
        rejectSignInPromise,
    ]);
    // Public sign-in method
    const signIn = useCallback(async () => {
        if (displayMode === "iframe") {
            setIframeIsVisible(true);
        }
        return startSignIn();
    }, [startSignIn, displayMode, setIframeIsVisible]);
    // Sign-out method
    const signOut = useCallback(async () => {
        const idToken = session?.idToken;
        if (!authInitiator)
            return;
        setAuthStatus(AuthStatus.SIGNING_OUT);
        if (displayMode === "iframe") {
            setIframeIsVisible(false);
            setLogoutIframeIsVisible(true);
        }
        try {
            await preSignOut?.();
            const useIframeRef = logoutIframeRef?.current || null;
            await authInitiator.signOut(idToken, useIframeRef).catch((error) => {
                setAuthStatus(AuthStatus.ERROR);
                console.error("signOut error", {
                    error,
                    isPopupError: error instanceof PopupError,
                });
                if (error instanceof PopupError) {
                    setLogoutIframeIsVisible(false);
                    authInitiator.cleanup();
                    authInitiator.setDisplayMode("redirect");
                    authInitiator.signOut(idToken, useIframeRef); // Retry sign out
                }
            });
        }
        catch (error) {
            console.error("Signout error:", error);
            setAuthStatus(AuthStatus.ERROR);
        }
    }, [
        session?.idToken,
        authInitiator,
        displayMode,
        setLogoutIframeIsVisible,
        setIframeIsVisible,
        preSignOut,
        logoutIframeRef,
        setAuthStatus,
    ]);
    // Set up event listeners for authentication status
    useEffect(() => {
        // Update the ref with current auth status
        authStatusRef.current = authStatus;
        // Define handlers
        handlersRef.current = {
            handleSignInComplete: () => {
                if (authStatusRef.current === AuthStatus.AUTHENTICATING) {
                    resolveSignInPromise();
                }
            },
            handleSignInError: (event) => {
                if (authStatusRef.current === AuthStatus.AUTHENTICATING) {
                    const error = event.detail.error;
                    rejectSignInPromise(error instanceof Error
                        ? error
                        : new Error(error.message || "Sign-in failed"));
                }
            },
        };
        // Add listeners only when in authenticating state
        if (authStatus === AuthStatus.AUTHENTICATING &&
            handlersRef.current.handleSignInComplete &&
            handlersRef.current.handleSignInError) {
            LocalStorageAdapter.emitter.on("civic-auth-signin-complete", handlersRef.current.handleSignInComplete);
            LocalStorageAdapter.emitter.on("civic-auth-signin-error", handlersRef.current.handleSignInError);
        }
        else if (authStatus !== AuthStatus.AUTHENTICATING &&
            timeoutRef.current !== null) {
            // Clean up timeout when not in authenticating state
            window.clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
        }
        // Cleanup listeners
        return () => {
            if (handlersRef.current.handleSignInComplete) {
                LocalStorageAdapter.emitter.off("civic-auth-signin-complete", handlersRef.current.handleSignInComplete);
            }
            if (handlersRef.current.handleSignInError) {
                LocalStorageAdapter.emitter.off("civic-auth-signin-error", handlersRef.current.handleSignInError);
            }
        };
    }, [authStatus, resolveSignInPromise, rejectSignInPromise]);
    // Effect to handle session updates and iframe aborts
    useEffect(() => {
        // If session becomes authenticated, update state and resolve pending promises
        if (session?.authenticated &&
            authStatusRef.current !== AuthStatus.AUTHENTICATED) {
            setAuthStatus(AuthStatus.AUTHENTICATED);
            // If we have a pending sign-in promise, resolve it
            if (authStatusRef.current === AuthStatus.AUTHENTICATING &&
                signInResolveRef.current) {
                resolveSignInPromise();
            }
        }
        // Handle iframe abortion
        if (displayMode === "iframe" && iframeAborted) {
            setIframeAborted(false);
            if (authStatusRef.current === AuthStatus.AUTHENTICATING) {
                rejectSignInPromise(new Error("Sign-in aborted by user"), AuthStatus.UNAUTHENTICATED);
            }
        }
        // Update unauthenticated state when session is absent
        if (!session?.authenticated &&
            ![AuthStatus.AUTHENTICATING, AuthStatus.SIGNING_OUT].includes(authStatusRef.current)) {
            if (authStatusRef.current !== AuthStatus.UNAUTHENTICATED) {
                setAuthStatus(AuthStatus.UNAUTHENTICATED);
            }
        }
    }, [
        displayMode,
        iframeAborted,
        session?.authenticated,
        setIframeAborted,
        resolveSignInPromise,
        rejectSignInPromise,
        setAuthStatus,
    ]);
    // Handle logout completion
    useEffect(() => {
        if (authStatus === AuthStatus.SIGNING_OUT && !session?.authenticated) {
            setAuthStatus(AuthStatus.UNAUTHENTICATED);
            postSignOut?.().then(() => {
                setLogoutIframeIsVisible(false);
            });
        }
    }, [
        session,
        postSignOut,
        setLogoutIframeIsVisible,
        authStatus,
        setAuthStatus,
    ]);
    return {
        signIn,
        signOut,
        startSignIn,
        authStatus,
        displayMode,
    };
};
export { useSignIn };
//# sourceMappingURL=useSignIn.js.map