/**
 * useUser Hook
 *
 * A comprehensive user session hook that provides full user data including profile information,
 * authentication tokens, and authentication state. Supports generic typing for custom user data.
 *
 * Use this hook when you:
 * - Need access to user profile information (user object)
 * - Need authentication tokens (JWT, access, refresh tokens)
 * - Are working with custom user data types
 * - Need comprehensive user session data
 * - Want backward compatibility with legacy UserContext
 *
 * This hook supports two authentication patterns with automatic fallback:
 * 1. Provider-based (legacy): Uses CivicAuthProvider or CivicNextAuthProvider
 * 2. Provider-free (modern): Direct configuration via useUser(config)
 *
 * Usage Examples:
 *
 * // With provider (existing approach - NextJS/React providers)
 * <CivicAuthProvider clientId="..." config={{ oauthServer: "..." }}>
 *   const { user, isLoading, signIn } = useUser();
 * </CivicAuthProvider>
 *
 * // Without provider (new approach) - direct configuration
 * const { user, authStatus, signOut } = useUser({
 *   clientId: "your-client-id",
 *   config: { oauthServer: "https://auth.civic.com/oauth/" },
 *   displayMode: "iframe", // or "redirect", "popup", etc.
 *   scopes: ["openid", "profile", "email"],
 *   onSignIn: (error) => console.log("Sign in completed", error),
 *   onSignOut: () => console.log("Sign out completed")
 * });
 *
 * // Generic typing for custom user data
 * interface CustomUser { customField: string; }
 * const { user } = useUser<CustomUser>(); // user will be User<CustomUser> | null
 */
"use client";
import { useContext, useState, useEffect, useCallback, useMemo } from "react";
import { UserContext } from "../../shared/providers/UserProvider.js";
import { GlobalAuthManager, } from "../core/GlobalAuthManager.js";
import { extractTokensFromSession } from "../../vanillajs/utils/auth-utils.js";
const useUser = (config) => {
    // Always call context hooks unconditionally (rules of hooks)
    const sharedContext = useContext(UserContext);
    // State for global manager approach
    const [globalState, setGlobalState] = useState(null);
    // Determine which approach to use
    const hasProviderContext = sharedContext;
    const shouldUseGlobal = !hasProviderContext;
    // Initialize global manager if no provider context
    useEffect(() => {
        if (!shouldUseGlobal)
            return;
        const manager = GlobalAuthManager.getInstance();
        // If config is provided, initialize with it
        if (config) {
            const initializeAuth = async () => {
                try {
                    await manager.initialize(config);
                }
                catch (error) {
                    console.error("Failed to initialize auth:", error);
                }
            };
            initializeAuth();
        }
        // Subscribe to state changes
        const unsubscribe = manager.subscribe((newState) => {
            setGlobalState(newState);
        });
        // Get current state
        setGlobalState(manager.getState());
        return unsubscribe;
    }, [shouldUseGlobal, config]);
    // Global manager sign in/out functions
    const globalSignIn = useCallback(async () => {
        const manager = GlobalAuthManager.getInstance();
        await manager.signIn();
        // Get the user after sign in
        const state = manager.getState();
        if (!state.user) {
            throw new Error("Authentication succeeded but no user was returned");
        }
        return { user: state.user };
    }, []);
    const globalSignOut = useCallback(async () => {
        const manager = GlobalAuthManager.getInstance();
        await manager.signOut();
    }, []);
    // Extract tokens from global state
    const globalTokens = useMemo(() => {
        return extractTokensFromSession(globalState?.session || null);
    }, [globalState?.session]);
    // Create wrapper functions for different signIn signatures
    const wrapSharedSignIn = useCallback(async () => {
        if (sharedContext) {
            await sharedContext.signIn(); // This returns void
            // Get user from context after sign in
            if (sharedContext.user) {
                return { user: sharedContext.user };
            }
            // We don't return a user yet in nextjs until the next refactor
            return { user: null };
        }
        throw new Error("Shared context not available");
    }, [sharedContext]);
    // ========================================================================
    // FALLBACK PRIORITY SYSTEM - Two authentication context approaches
    // ========================================================================
    // 1. DEPRECATED UserContext (ACTIVE - Used by NextJS)
    // Framework-agnostic shared context from UserProvider
    // Location: shared/providers/UserProvider.tsx
    // Usage: NextJS example uses CivicNextAuthProvider → UserProvider → UserContext
    if (sharedContext) {
        return {
            user: sharedContext.user,
            idToken: sharedContext.idToken,
            accessToken: sharedContext.accessToken,
            refreshToken: undefined, // Not available in shared context
            forwardedTokens: sharedContext.forwardedTokens,
            isLoading: sharedContext.isLoading,
            authStatus: sharedContext.authStatus,
            error: sharedContext.error,
            signIn: wrapSharedSignIn,
            signOut: sharedContext.signOut,
            displayMode: sharedContext.displayMode,
        };
    }
    // 2. GlobalAuthManager (MODERN - Provider-free approach)
    // Singleton-based state management, eliminates need for React providers
    // Location: reactjs/core/GlobalAuthManager.ts
    // Usage: React example uses CivicAuthProvider → GlobalAuthManager internally
    // Can also be used directly: useUser({ clientId: "...", config: {...} })
    if (globalState) {
        return {
            user: globalState.user,
            idToken: globalTokens.idToken,
            accessToken: globalTokens.accessToken,
            refreshToken: globalTokens.refreshToken,
            forwardedTokens: globalTokens.forwardedTokens,
            isLoading: globalState.isLoading,
            authStatus: globalState.authStatus,
            error: globalState.error,
            signIn: globalSignIn,
            signOut: globalSignOut,
            displayMode: globalState.displayMode,
        };
    }
    // If no context and no global state, provide default loading state
    // This happens when CivicAuthProvider is present but GlobalAuthManager hasn't initialized yet
    return {
        user: null,
        idToken: null,
        accessToken: null,
        refreshToken: null,
        forwardedTokens: undefined,
        isLoading: true,
        authStatus: "unauthenticated",
        error: null,
        signIn: globalSignIn,
        signOut: globalSignOut,
        displayMode: config?.displayMode,
    };
};
export { useUser };
//# sourceMappingURL=useUser.js.map