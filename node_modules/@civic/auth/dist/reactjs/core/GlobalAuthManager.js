/**
 * GlobalAuthManager - Singleton Authentication State Manager
 *
 * This module provides a global singleton that manages authentication state across a React application
 * without requiring React Context providers or prop drilling. It acts as a centralized authentication
 * manager that wraps the CivicAuth vanilla JavaScript library and provides a React-friendly interface.
 *
 * Key Features:
 * - Singleton pattern ensures single auth instance across the entire app
 * - Eliminates need for React Context providers and reduces bundle size
 * - Manages authentication state (user, session, loading, errors)
 * - Handles sign-in/sign-out flows with event-driven updates
 * - Provides idempotent initialization (safe to call multiple times)
 * - Supports multiple React hooks subscribing to the same auth state
 * - Automatic session refresh and user data synchronization
 *
 * Usage:
 * - Initialize once in your app with authentication configuration
 * - Use React hooks (useCivicAuth, useAuth, etc.) to access auth state
 * - The manager handles all underlying CivicAuth SDK interactions
 * - State updates are automatically propagated to all subscribed components
 *
 * This design pattern is particularly useful for:
 * - Large applications with many components needing auth state
 * - Avoiding provider wrapper hell in React component trees
 * - Ensuring consistent auth state across disconnected component hierarchies
 * - Server-side rendering scenarios where providers might be problematic
 */
import { CivicAuth, AuthenticationEvents, AuthEvent, } from "../../vanillajs/index.js";
/**
 * Global singleton that manages CivicAuth instance for React hooks
 * Eliminates the need for React providers
 */
class GlobalAuthManager {
    static instance = null;
    auth = null;
    events = null;
    config = null;
    listeners = new Set();
    callbacks = {};
    initializationPromise = null;
    state = {
        user: null,
        session: null,
        isLoading: false,
        authStatus: "unauthenticated",
        error: null,
        displayMode: undefined,
    };
    constructor() {
        // Private constructor for singleton
    }
    static getInstance() {
        if (!GlobalAuthManager.instance) {
            GlobalAuthManager.instance = new GlobalAuthManager();
        }
        return GlobalAuthManager.instance;
    }
    /**
     * Initialize auth with config (idempotent)
     * Returns the same promise for concurrent calls with same config
     */
    async initialize(config) {
        // If we have a promise and same config, return existing promise
        if (this.initializationPromise &&
            this.config &&
            this.isSameConfig(config)) {
            return this.initializationPromise;
        }
        // If different config, reset everything
        if (this.config && !this.isSameConfig(config)) {
            this.initializationPromise = null;
            await this.cleanup();
        }
        // Create new initialization promise if needed
        if (!this.initializationPromise) {
            this.initializationPromise = this._doInitialize(config);
        }
        return this.initializationPromise;
    }
    /**
     * Private method that does the actual initialization work
     */
    async _doInitialize(config) {
        this.config = config;
        this.callbacks = {
            onSignIn: config.onSignIn,
            onSignOut: config.onSignOut,
        };
        this.setState({ isLoading: true, error: null });
        try {
            this.events = new AuthenticationEvents();
            this.setupEventListeners();
            const authConfig = {
                clientId: config.clientId,
                oauthServerBaseUrl: config.config?.oauthServer,
                scopes: config.scopes || [
                    "openid",
                    "profile",
                    "email",
                    "offline_access",
                ],
                displayMode: config.displayMode || "iframe",
                iframeDisplayMode: config.iframeMode || "modal",
                nonce: config.nonce,
                authProcessTimeout: config.authProcessTimeout || 120000,
                events: this.events,
                logging: {
                    enabled: true,
                    level: "debug",
                },
            };
            // Only add redirectUrl if provided
            if (config.redirectUrl) {
                authConfig.redirectUrl = config.redirectUrl;
            }
            // Only add logoutRedirectUrl if provided
            if (config.logoutRedirectUrl) {
                authConfig.logoutRedirectUrl = config.logoutRedirectUrl;
            }
            this.auth = await CivicAuth.create(authConfig);
            // Check initial auth state
            const isAuthenticated = await this.auth.isAuthenticated();
            if (isAuthenticated) {
                await this.refreshUserAndSession();
                this.setState({ authStatus: "authenticated" });
            }
            else {
                this.setState({ authStatus: "unauthenticated" });
            }
            this.setState({
                isLoading: false,
                displayMode: config.displayMode,
            });
        }
        catch (error) {
            // Reset promise on error so it can be retried
            this.initializationPromise = null;
            const authError = error instanceof Error
                ? error
                : new Error("Auth initialization failed");
            this.setState({
                error: authError,
                authStatus: "error",
                isLoading: false,
            });
            throw authError;
        }
    }
    /**
     * Subscribe to state changes
     */
    subscribe(listener) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }
    /**
     * Get current state
     */
    getState() {
        return { ...this.state };
    }
    /**
     * Sign in
     */
    async signIn() {
        if (!this.auth) {
            throw new Error("Auth not initialized");
        }
        const { user } = await this.auth.startAuthentication();
        await this.refreshUserAndSession();
        // Ensure we have a user to return
        if (!user) {
            throw new Error("Authentication succeeded but no user was returned");
        }
        // Return the user object
        return { user };
    }
    /**
     * Sign out
     */
    async signOut() {
        if (!this.auth) {
            throw new Error("Auth not initialized");
        }
        await this.auth.logout();
        this.setState({
            user: null,
            session: null,
            authStatus: "unauthenticated",
        });
    }
    /**
     * Check if config is the same (for idempotent initialization)
     */
    isSameConfig(newConfig) {
        if (!this.config)
            return false;
        return (this.config.clientId === newConfig.clientId &&
            this.config.config?.oauthServer === newConfig.config?.oauthServer &&
            this.config.displayMode === newConfig.displayMode &&
            this.config.nonce === newConfig.nonce);
    }
    /**
     * Setup event listeners for auth state changes
     */
    setupEventListeners() {
        if (!this.events)
            return;
        this.events.on(AuthEvent.SIGN_IN_STARTED, () => {
            this.setState({
                isLoading: true,
                authStatus: "authenticating",
                error: null,
            });
        });
        this.events.on(AuthEvent.SIGN_IN_COMPLETE, () => {
            this.setState({
                isLoading: false,
                authStatus: "authenticated",
                error: null,
            });
            this.refreshUserAndSession();
            this.callbacks.onSignIn?.();
        });
        this.events.on(AuthEvent.SIGN_IN_ERROR, (event) => {
            const errorDetail = event?.detail || "Authentication failed";
            const authError = new Error(errorDetail);
            this.setState({
                isLoading: false,
                authStatus: "error",
                error: authError,
            });
            this.callbacks.onSignIn?.(authError);
        });
        this.events.on(AuthEvent.SIGN_OUT_STARTED, () => {
            this.setState({
                isLoading: true,
                authStatus: "signing_out",
                error: null,
            });
        });
        this.events.on(AuthEvent.SIGN_OUT_COMPLETE, () => {
            this.setState({
                isLoading: false,
                authStatus: "unauthenticated",
                user: null,
                session: null,
                error: null,
            });
            this.callbacks.onSignOut?.();
        });
        this.events.on(AuthEvent.USER_SESSION_CHANGED, () => {
            this.refreshUserAndSession();
        });
    }
    /**
     * Refresh user and session data
     */
    async refreshUserAndSession() {
        if (!this.auth)
            return;
        try {
            const [session, user] = await Promise.all([
                this.auth.getCurrentSession(),
                this.auth.getCurrentUser(),
            ]);
            this.setState({ session, user });
        }
        catch (error) {
            const sessionError = error instanceof Error ? error : new Error("Failed to get session");
            this.setState({ error: sessionError });
        }
    }
    /**
     * Update state and notify listeners
     */
    setState(updates) {
        this.state = { ...this.state, ...updates };
        this.listeners.forEach((listener) => listener(this.state));
    }
    /**
     * Cleanup auth instance
     */
    async cleanup() {
        if (this.auth) {
            await this.auth.destroy();
            this.auth = null;
        }
        this.events = null;
        this.config = null;
        this.initializationPromise = null; // Reset promise for clean re-initialization
    }
}
export { GlobalAuthManager };
//# sourceMappingURL=GlobalAuthManager.js.map