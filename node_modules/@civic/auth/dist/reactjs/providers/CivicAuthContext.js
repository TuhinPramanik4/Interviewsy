"use client";
import { jsx as _jsx } from "@emotion/react/jsx-runtime";
import React, { createContext, useContext, useEffect, useState, useCallback, useMemo, useRef, } from "react";
import { CivicAuth, AuthEvent, } from "../../vanillajs/index.js";
import { AuthenticationEvents } from "../../vanillajs/auth/AuthenticationEvents.js";
import { extractTokensFromSession } from "../../vanillajs/utils/auth-utils.js";
const CivicAuthContext = createContext(null);
export const CivicAuthContextProvider = ({ children, clientId, redirectUrl, oauthServerBaseUrl = "https://auth.civic.com/oauth/", scopes = ["openid", "profile", "email", "offline_access"], displayMode = "iframe", iframeDisplayMode = "modal", onSignIn, onSignOut, nonce, authProcessTimeout = 120000, }) => {
    const [auth, setAuth] = useState(null);
    const [user, setUser] = useState(null);
    const [session, setSession] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [authStatus, setAuthStatus] = useState("unauthenticated");
    const [error, setError] = useState(null);
    // Track initialization to prevent double-execution in React StrictMode
    const initializationRef = useRef({
        isInitializing: false,
        isInitialized: false,
    });
    useEffect(() => {
        let isMounted = true;
        // Prevent double initialization in React StrictMode
        if (initializationRef.current.isInitializing ||
            initializationRef.current.isInitialized) {
            // `[CivicAuthContext] Skipping initialization ${initId} - already initializing/initialized`,
            return;
        }
        // Capture ref value at effect setup time for cleanup
        const initializationState = initializationRef.current;
        initializationRef.current.isInitializing = true;
        const refreshUserAndSession = async () => {
            if (!auth)
                return;
            try {
                const currentSession = await auth.getCurrentSession();
                const currentUser = await auth.getCurrentUser();
                if (isMounted) {
                    setSession(currentSession);
                    setUser(currentUser);
                }
            }
            catch (err) {
                if (isMounted) {
                    const sessionError = err instanceof Error ? err : new Error("Failed to get session");
                    setError(sessionError);
                }
            }
        };
        const initializeAuth = async () => {
            try {
                const events = new AuthenticationEvents();
                // Set up event listeners
                events.on(AuthEvent.SIGN_IN_STARTED, () => {
                    if (isMounted) {
                        setIsLoading(true);
                        setAuthStatus("authenticating");
                        setError(null);
                    }
                });
                events.on(AuthEvent.SIGN_IN_COMPLETE, () => {
                    if (isMounted) {
                        setIsLoading(false);
                        setAuthStatus("authenticated");
                        setError(null);
                        onSignIn?.();
                    }
                });
                events.on(AuthEvent.SIGN_IN_ERROR, (event) => {
                    if (isMounted) {
                        setIsLoading(false);
                        setAuthStatus("error");
                        const errorDetail = event?.detail || "Authentication failed";
                        const authError = new Error(errorDetail);
                        setError(authError);
                        onSignIn?.(authError);
                    }
                });
                events.on(AuthEvent.SIGN_OUT_STARTED, () => {
                    if (isMounted) {
                        setIsLoading(true);
                        setAuthStatus("signing_out");
                        setError(null);
                    }
                });
                events.on(AuthEvent.SIGN_OUT_COMPLETE, () => {
                    if (isMounted) {
                        setIsLoading(false);
                        setAuthStatus("unauthenticated");
                        setUser(null);
                        setSession(null);
                        setError(null);
                        onSignOut?.();
                    }
                });
                events.on(AuthEvent.USER_SESSION_CHANGED, () => {
                    if (isMounted) {
                        refreshUserAndSession();
                    }
                });
                const authInstance = await CivicAuth.create({
                    clientId,
                    redirectUrl: redirectUrl ||
                        `${window.location.origin}${window.location.pathname}`,
                    oauthServerBaseUrl,
                    scopes,
                    displayMode,
                    iframeDisplayMode,
                    nonce,
                    authProcessTimeout,
                    events,
                });
                if (isMounted) {
                    setAuth(authInstance);
                    // Mark initialization as complete
                    initializationRef.current.isInitializing = false;
                    initializationRef.current.isInitialized = true;
                    // Check initial auth state
                    const isAuthenticated = await authInstance.isAuthenticated();
                    if (isAuthenticated) {
                        setAuthStatus("authenticated");
                        await refreshUserAndSession();
                    }
                    else {
                        setAuthStatus("unauthenticated");
                        // Pre-load iframe for iframe display mode to match old behavior
                        // This prepares the iframe in the background so it's ready to be shown
                        if (displayMode === "iframe") {
                            try {
                                // Pre-load by setting iframe display mode - this doesn't show it but prepares it
                                authInstance.setIframeDisplayMode(iframeDisplayMode);
                            }
                            catch (err) {
                                // Don't fail initialization if iframe pre-loading fails
                                console.warn("Iframe pre-loading failed:", err);
                            }
                        }
                    }
                    // Mark initialization as complete
                    setIsLoading(false);
                }
            }
            catch (err) {
                console.error(err);
                if (isMounted) {
                    const initError = err instanceof Error ? err : new Error("Failed to initialize auth");
                    setError(initError);
                    setAuthStatus("error");
                    setIsLoading(false); // Stop loading even on error
                    // Mark initialization as failed
                    initializationRef.current.isInitializing = false;
                    // Don't mark as initialized on error so it can be retried
                }
            }
        };
        initializeAuth();
        return () => {
            isMounted = false;
            // Reset initialization guards to allow remount to reinitialize
            // This is necessary for React StrictMode compatibility
            if (initializationState.isInitializing) {
                initializationState.isInitializing = false;
                initializationState.isInitialized = false;
            }
            if (auth) {
                auth.destroy();
            }
        };
        // Refresh user and session when auth instance changes
        /*
         * Intentionally omitting dependencies to prevent infinite loops.
         * Adding auth, onSignIn, onSignOut, and scopes to the dependency array would cause
         * the effect to re-run whenever these values change, which could lead to unnecessary
         * re-renders and potential infinite loops since the effect updates state that might
         * trigger re-renders of parent components.
         *
         * IMPORTANT: redirectUrl is intentionally omitted to prevent re-initialization
         * during OAuth callback when URL parameters change, which would cause
         * "invalid_grant" errors due to authorization code reuse.
         */
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        clientId,
        oauthServerBaseUrl,
        displayMode,
        iframeDisplayMode,
        nonce,
        authProcessTimeout,
    ]);
    // This is on load to get the user and session
    useEffect(() => {
        if (auth && authStatus === "authenticated") {
            const refreshUserAndSession = async () => {
                try {
                    const currentSession = await auth.getCurrentSession();
                    const currentUser = await auth.getCurrentUser();
                    setSession(currentSession);
                    setUser(currentUser);
                }
                catch (err) {
                    const sessionError = err instanceof Error ? err : new Error("Failed to get session");
                    setError(sessionError);
                }
            };
            refreshUserAndSession();
        }
    }, [auth, authStatus]);
    const signIn = useCallback(async () => {
        if (!auth) {
            // If auth is still loading, provide a more helpful error
            if (isLoading) {
                throw new Error("Authentication is still initializing, please wait...");
            }
            throw new Error("Auth not initialized");
        }
        try {
            const { user } = await auth.startAuthentication();
            // Refresh user and session after successful authentication
            const currentSession = await auth.getCurrentSession();
            setSession(currentSession);
            setUser(user ?? null);
            // Ensure we have a user to return
            if (!user) {
                throw new Error("Authentication succeeded but no user was returned");
            }
            // Return the user object
            return { user };
        }
        catch (err) {
            const signInError = err instanceof Error ? err : new Error("Sign in failed");
            setError(signInError);
            throw signInError;
        }
    }, [auth, isLoading]);
    const signOut = useCallback(async () => {
        if (!auth) {
            // If auth is still loading, provide a more helpful error
            if (isLoading) {
                throw new Error("Authentication is still initializing, please wait...");
            }
            throw new Error("Auth not initialized");
        }
        try {
            await auth.logout();
            setUser(null);
            setSession(null);
        }
        catch (err) {
            const signOutError = err instanceof Error ? err : new Error("Sign out failed");
            setError(signOutError);
            throw signOutError;
        }
    }, [auth, isLoading]);
    // Extract tokens from session
    const idToken = session?.idToken;
    const accessToken = session?.accessToken;
    const refreshToken = session?.refreshToken;
    // Extract forwardedTokens from session's ID token
    const forwardedTokens = useMemo(() => {
        if (!session)
            return undefined;
        const tokens = extractTokensFromSession(session);
        return tokens.forwardedTokens;
    }, [session]);
    const contextValue = useMemo(() => ({
        auth,
        user,
        session,
        isLoading,
        authStatus,
        error,
        idToken,
        accessToken,
        refreshToken,
        forwardedTokens,
        signIn,
        signOut,
        displayMode,
    }), [
        auth,
        user,
        session,
        isLoading,
        authStatus,
        error,
        idToken,
        accessToken,
        refreshToken,
        forwardedTokens,
        signIn,
        signOut,
        displayMode,
    ]);
    return (_jsx(CivicAuthContext.Provider, { value: contextValue, children: children }));
};
export const useCivicAuthContext = () => {
    const context = useContext(CivicAuthContext);
    if (!context) {
        throw new Error("useCivicAuthContext must be used within a CivicAuthContextProvider");
    }
    return context;
};
export { CivicAuthContext };
//# sourceMappingURL=CivicAuthContext.js.map