import { AuthEvent } from "../../types/index.js";
import { CivicAuthError, CivicAuthErrorCode } from "../types/AuthTypes.js";
import { SignalObserver } from "../../iframe/SignalObserver.js";
import { IframeManager } from "../../iframe/IframeManager.js";
import { createLogger as createLoggerFn } from "../../utils/logger.js";
export class IframeAuthHandler {
    config;
    logger = createLoggerFn("iframe-auth");
    onAuthSuccess;
    onAuthError;
    cleanup;
    messageHandler;
    iframeManager;
    iframeElement;
    signalObserver;
    constructor(handlerConfig) {
        this.config = handlerConfig.config;
        this.onAuthSuccess = handlerConfig.onAuthSuccess;
        this.onAuthError = handlerConfig.onAuthError;
        this.cleanup = handlerConfig.cleanup;
        this.messageHandler = handlerConfig.messageHandler;
    }
    async handleIframeAuth(fullAuthUrl) {
        // Determine the actual display mode for IframeManager first
        const iframeDisplayMode = this.determineIframeDisplayMode();
        let container = this.getContainerElement();
        // For modal mode, if no container is provided, create one dynamically
        if (iframeDisplayMode === "modal" && !container) {
            container = this.createModalContainer();
        }
        if (!container) {
            const error = new CivicAuthError("Target container element not found.", CivicAuthErrorCode.CONTAINER_NOT_FOUND);
            this.logger.error(error.message);
            throw error;
        }
        this.logger.debug("Creating iframe with modal backdrop", {
            url: fullAuthUrl,
            containerId: container?.id,
            iframeId: this.config.iframeId,
            origin: window.location.origin,
            iframeDisplayMode,
            containerCreated: iframeDisplayMode === "modal" && !this.config.targetContainerElement,
        });
        this.logger.debug(`ðŸŽ¯ CivicAuth: Creating IframeManager with display mode: ${iframeDisplayMode}`);
        // Create IframeManager with appropriate display mode
        this.iframeManager = new IframeManager({
            container: container,
            displayMode: iframeDisplayMode,
            iframeId: this.config.iframeId,
            /**
             * Handles iframe closure events initiated by the user.
             * This includes backdrop clicks, close button clicks, or Escape key presses.
             * Emits an error event and cleans up the authentication process.
             */
            onClose: () => {
                this.logger.debug("Authentication close requested by user (backdrop click, close button, or Escape key)");
                this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
                    detail: "Authentication cancelled by user",
                });
                const error = new CivicAuthError("Authentication cancelled by user", CivicAuthErrorCode.USER_CANCELLED);
                this.onAuthError(error);
                this.cleanup();
            },
        });
        // Create the iframe using IframeManager
        this.iframeElement = this.iframeManager.createIframe(fullAuthUrl);
        this.config.events?.emit(AuthEvent.SIGN_IN_STARTED, {
            detail: "Iframe created with modal backdrop",
        });
        this.setupIframeEventHandlers();
        this.setupIframeNavigationMonitoring();
        return this.iframeElement;
    }
    getIframeManager() {
        return this.iframeManager;
    }
    getIframeElement() {
        return this.iframeElement;
    }
    cleanupIframe() {
        if (this.iframeManager) {
            this.logger.debug("Cleaning up iframe manager");
            this.iframeManager.cleanup();
            this.iframeManager = undefined;
        }
        if (this.iframeElement) {
            this.iframeElement = undefined;
        }
        // Clean up dynamically created modal containers
        this.cleanupDynamicModalContainer();
    }
    cleanupDynamicModalContainer() {
        // Only clean up containers we created dynamically (not user-provided ones)
        if (!this.config.targetContainerElement) {
            const dynamicContainer = document.querySelector(`[data-civic-auth-modal="true"]#${this.config.iframeId}-modal-container`);
            if (dynamicContainer && dynamicContainer.parentNode) {
                this.logger.debug("Removing dynamic modal container", {
                    containerId: dynamicContainer.id,
                });
                dynamicContainer.parentNode.removeChild(dynamicContainer);
            }
        }
    }
    createModalContainer() {
        const container = document.createElement("div");
        container.id = `${this.config.iframeId}-modal-container`;
        container.setAttribute("data-civic-auth-modal", "true");
        // Append to body for modal overlay
        document.body.appendChild(container);
        this.logger.debug("Created dynamic modal container", {
            containerId: container.id,
        });
        return container;
    }
    getContainerElement() {
        if (!this.config.targetContainerElement) {
            return null;
        }
        if (typeof this.config.targetContainerElement === "string") {
            const element = document.getElementById(this.config.targetContainerElement);
            if (!element) {
                this.logger.warn(`Container element with ID "${this.config.targetContainerElement}" not found`);
            }
            return element;
        }
        return this.config.targetContainerElement;
    }
    determineIframeDisplayMode() {
        // Priority 1: Explicit iframeDisplayMode setting from config
        // This is the most specific instruction for how the iframe itself should be styled.
        if (this.config.iframeDisplayMode) {
            this.logger.debug(`Using configured iframeDisplayMode: ${this.config.iframeDisplayMode}`);
            return this.config.iframeDisplayMode;
        }
        // Priority 2: If iframeDisplayMode is NOT set, and the overall displayMode is "iframe",
        // default the iframe's own rendering style to "modal" (user-friendly default).
        // To get an embedded iframe, iframeDisplayMode: "embedded" should be set explicitly.
        if (this.config.displayMode === "iframe") {
            this.logger.debug("Overall displayMode is 'iframe' and iframeDisplayMode is not set, defaulting iframe style to 'modal'.");
            return "modal";
        }
        // Fallback for unexpected scenarios or if IframeAuthHandler is invoked with other displayModes.
        this.logger.warn(`determineIframeDisplayMode called with overall displayMode: '${this.config.displayMode}' ` +
            `and no explicit iframeDisplayMode. Defaulting iframe style to 'modal'.`);
        return "modal";
    }
    setupIframeEventHandlers() {
        if (!this.iframeElement)
            return;
        this.iframeElement.onload = () => {
            this.logger.info("Iframe loaded", {
                iframeSrc: this.iframeElement?.src,
                currentOrigin: window.location.origin,
                expectedAuthServerOrigin: new URL(this.config.oauthServerBaseUrl)
                    .origin,
            });
            if (!this.iframeElement?.contentWindow) {
                const errorMsg = "Iframe content window not available after load.";
                this.logger.error(errorMsg, {
                    iframeSrc: this.iframeElement?.src,
                });
                const error = new Error(errorMsg);
                this.onAuthError(error);
                this.cleanup();
                return;
            }
            // Set up postMessage listener for cross-origin communication
            window.addEventListener("message", this.messageHandler);
            this.logger.info("Added cross-origin message event listener for auth server communication", {
                parentOrigin: window.location.origin,
                authServerOrigin: new URL(this.config.oauthServerBaseUrl).origin,
            });
            // Hide iframe content if it's not the login app
            this.checkAndHideNonLoginContent();
            // Try to detect redirect to our domain
            this.checkIframeRedirect();
        };
        this.iframeElement.onerror = (event) => {
            this.logger.error("Iframe load error", {
                event,
                iframeSrc: this.iframeElement?.src,
                currentOrigin: window.location.origin,
            });
            this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
                detail: "Iframe load error",
                error: event,
            });
            const error = new Error("Iframe failed to load.");
            this.onAuthError(error);
            this.cleanup();
        };
    }
    checkAndHideNonLoginContent() {
        try {
            const currentUrl = this.iframeElement?.contentWindow?.location.href;
            if (currentUrl) {
                const currentOrigin = new URL(currentUrl).origin;
                const expectedAuthServerOrigin = this.config.oauthServerBaseUrl
                    ? new URL(this.config.oauthServerBaseUrl).origin
                    : null;
                const isOnAuthServer = expectedAuthServerOrigin
                    ? currentOrigin === expectedAuthServerOrigin
                    : false;
                const isCallbackUrl = this.config.redirectUrl
                    ? currentUrl.startsWith(this.config.redirectUrl)
                    : false;
                if (isOnAuthServer && !isCallbackUrl) {
                    this.logger.info("ðŸ‘€ Showing iframe content - confirmed login app on auth server origin", {
                        currentUrl,
                        isOnAuthServer,
                        isCallbackUrl,
                        currentOrigin,
                        expectedAuthServerOrigin,
                    });
                    if (this.iframeManager) {
                        this.iframeManager.forceHideLoader();
                    }
                }
                else {
                    this.logger.info("ðŸ™ˆ Masking iframe content with loader - not login app or on callback URL", {
                        currentUrl,
                        isOnAuthServer,
                        isCallbackUrl,
                        currentOrigin,
                        expectedAuthServerOrigin,
                        reason: !isOnAuthServer
                            ? expectedAuthServerOrigin
                                ? "not on auth server (origin mismatch)"
                                : "auth server origin unknown"
                            : "on callback URL (or origin mismatch for login page)",
                    });
                    if (this.iframeManager) {
                        this.iframeManager.forceShowLoader();
                    }
                }
            }
        }
        catch (error) {
            this.logger.debug("Cannot access iframe URL (likely cross-origin) - assuming login app, showing content.", { error: error instanceof Error ? error.message : String(error) });
            if (this.iframeManager) {
                this.iframeManager.forceHideLoader();
            }
        }
    }
    checkIframeRedirect() {
        try {
            const currentIframeHref = this.iframeElement?.contentWindow?.location.href;
            if (currentIframeHref) {
                this.logger.debug("Iframe current href accessible", {
                    href: currentIframeHref,
                    redirectUrl: this.config.redirectUrl,
                    startsWithRedirect: currentIframeHref.startsWith(this.config.redirectUrl),
                });
                if (currentIframeHref.startsWith(this.config.redirectUrl)) {
                    this.logger.info("Iframe has navigated to redirectUrl (same-origin). Setting up DOM observer.");
                    // Hide content since we're on callback page now
                    this.checkAndHideNonLoginContent();
                    // Set up signal observer for same-origin callback page
                    if (this.iframeElement?.contentDocument &&
                        this.iframeElement.contentDocument.body) {
                        this.setupSignalObserver(this.iframeElement.contentDocument);
                    }
                    else {
                        this.logger.warn("Iframe content document or body not available for signal observer");
                    }
                }
            }
        }
        catch (error) {
            this.logger.debug("Error checking iframe href (expected for cross-origin)", {
                error: error instanceof Error ? error.message : String(error),
                iframeSrc: this.iframeElement?.src,
            });
            // This is expected when the iframe is on the auth server domain
            this.logger.info("Iframe is on auth server domain - using postMessage for communication", {
                parentOrigin: window.location.origin,
                authServerOrigin: new URL(this.config.oauthServerBaseUrl).origin,
            });
        }
    }
    setupSignalObserver(iframeDoc) {
        const signalObserver = new SignalObserver({
            textSignals: this.config.textSignals,
            events: this.config.events,
            logger: this.logger,
        }, this.onAuthSuccess, (error) => this.onAuthError(error || new Error("Signal observer error")), () => this.cleanup());
        signalObserver.setup(iframeDoc);
    }
    setupIframeNavigationMonitoring() {
        // Monitor iframe navigation to detect when it redirects to our callback URL
        let monitoringInterval = undefined;
        let lastKnownUrl = "";
        const checkIframeNavigation = () => {
            if (!this.iframeElement?.contentWindow) {
                if (monitoringInterval) {
                    clearInterval(monitoringInterval);
                }
                return;
            }
            try {
                const currentUrl = this.iframeElement.contentWindow.location.href;
                if (currentUrl !== lastKnownUrl) {
                    lastKnownUrl = currentUrl;
                    this.logger.debug("Iframe navigation detected", {
                        newUrl: currentUrl,
                        redirectUrl: this.config.redirectUrl,
                        isCallbackUrl: currentUrl.startsWith(this.config.redirectUrl),
                    });
                    // Hide content if not on login app
                    this.checkAndHideNonLoginContent();
                    // Check if iframe has navigated to our callback URL
                    if (currentUrl.startsWith(this.config.redirectUrl)) {
                        this.logger.info("Iframe navigated to callback URL - setting up signal observer");
                        if (monitoringInterval) {
                            clearInterval(monitoringInterval);
                        }
                        // Set up signal observer for same-origin callback page
                        if (this.iframeElement.contentDocument &&
                            this.iframeElement.contentDocument.body) {
                            this.setupSignalObserver(this.iframeElement.contentDocument);
                        }
                        // Also check for URL parameters (code, error) in case of direct callback
                        this.processCallbackUrl(currentUrl);
                    }
                }
            }
            catch {
                // Expected when iframe is on different origin
                // Only log if we haven't seen this before
                if (lastKnownUrl !== "cross-origin") {
                    lastKnownUrl = "cross-origin";
                    this.logger.debug("Iframe on cross-origin domain (expected during auth flow)");
                }
            }
        };
        // Check immediately and then every 500ms
        checkIframeNavigation();
        monitoringInterval = window.setInterval(checkIframeNavigation, 500);
        // Store cleanup function to clear monitoring
        const originalCleanup = this.cleanup;
        this.cleanup = () => {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }
            originalCleanup();
        };
    }
    processCallbackUrl(currentUrl) {
        const urlParams = new URLSearchParams(new URL(currentUrl).search);
        const code = urlParams.get("code");
        const error = urlParams.get("error");
        if (code) {
            this.logger.info("Authorization code detected in iframe URL", {
                code: code.substring(0, 10) + "...",
                hasState: !!urlParams.get("state"),
            });
        }
        if (error) {
            this.logger.error("OAuth error detected in iframe URL", {
                error,
                errorDescription: urlParams.get("error_description"),
            });
            const authError = new CivicAuthError(`OAuth error: ${error}`, CivicAuthErrorCode.INVALID_MESSAGE);
            this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
                detail: authError.message,
                error: urlParams.get("error_description") || error,
            });
            this.onAuthError(authError);
        }
    }
    navigateIframe(url) {
        if (!this.iframeElement) {
            this.logger.error("Cannot navigate iframe, iframeElement is not available.");
            this.onAuthError(new CivicAuthError("Iframe element not found for navigation.", CivicAuthErrorCode.IFRAME_NOT_FOUND));
            return;
        }
        if (!this.iframeManager) {
            this.logger.error("Cannot navigate iframe, iframeManager is not available.");
            this.onAuthError(new CivicAuthError("Iframe manager not found for navigation.", CivicAuthErrorCode.INTERNAL_ERROR));
            return;
        }
        this.logger.info("Navigating iframe to new URL", { url });
        this.iframeElement.src = url;
        // After changing src, existing onload/onmessage handlers in IframeManager
        // and navigation monitoring in this class should manage visibility and state.
    }
}
//# sourceMappingURL=IframeAuthHandler.js.map