import { AuthEvent } from "../types/index.js";
import { buildAuthUrl, extractTokensFromSession } from "../utils/auth-utils.js";
import { createMainLogger, configureLogging, setCurrentLogger, } from "../utils/logger.js";
import { GenericPublicClientPKCEProducer } from "../../services/PKCE.js";
import { generateState } from "../../lib/oauth.js";
import { SessionManager } from "./SessionManager.js";
import { AuthenticationEvents } from "./AuthenticationEvents.js";
import { PopupError } from "../../services/types.js";
import { handleOAuthRedirectPage } from "./handlers/OAuthCallbackHandler.js";
import { generateOauthLogoutUrl, clearTokens, retrieveTokens, } from "../../shared/lib/util.js";
import { LOGOUT_STATE } from "../../constants.js";
import { getOauthEndpoints } from "../../lib/oauth.js";
import { CivicAuthError, CivicAuthErrorCode, CIVIC_AUTH_CONSTANTS, } from "./types/AuthTypes.js";
import { processConfigWithDefaults } from "./config/ConfigProcessor.js";
import { MessageHandler } from "./handlers/MessageHandler.js";
import { PopupHandler } from "./handlers/PopupHandler.js";
import { IframeAuthHandler } from "./handlers/IframeAuthHandler.js";
/**
 * CivicAuth client for handling OAuth authentication
 *
 * This is a refactored version that uses a modular architecture for better maintainability.
 */
export class CivicAuth {
    config;
    storage;
    endpoints;
    logger;
    sessionManager;
    events;
    initialDisplayMode;
    // Authentication state
    authPromise;
    authPromiseResolve;
    authPromiseReject;
    authProcessTimeoutHandle;
    popupFailureTimeoutHandle;
    hasPopupFailed = false;
    // Handlers
    messageHandler;
    popupHandler;
    iframeAuthHandler;
    /**
     * Private constructor - initializes configuration and handlers.
     * Use {@link CivicAuth.create} to create a new instance.
     */
    constructor(config) {
        // Process config with defaults and validation
        this.config = processConfigWithDefaults(config);
        this.initialDisplayMode = this.config.displayMode;
        // Configure logging
        configureLogging(this.config.logging);
        // Initialize logger - always use "vanillajs" as base namespace
        if (this.config.logging?.enabled) {
            this.logger = createMainLogger("vanillajs"); // Always use "vanillajs"
        }
        else {
            this.logger = {
                debug: () => { },
                info: () => { },
                warn: () => { },
                error: () => { },
            };
        }
        setCurrentLogger(this.logger);
        this.storage = this.config.storageAdapter;
        // Always initialize events - use provided events or create default instance
        this.events = config.events || new AuthenticationEvents();
        // Always initialize SessionManager
        this.sessionManager = new SessionManager(this.storage, this.events);
        // Initialize handlers
        this.initializeHandlers();
    }
    /**
     * Creates and initializes a new instance of CivicAuth.
     * This is the recommended way to create a CivicAuth instance.
     *
     * @param config - Configuration options for the auth client
     * @returns A promise that resolves with the initialized CivicAuth instance
     * @throws {CivicAuthError} If initialization fails or required configuration is missing
     *
     * @example
     * ```typescript
     * const auth = await CivicAuth.create({
     *   clientId: "your-client-id",
     *   // redirectUrl is optional - defaults to current page (window.location.origin + window.location.pathname)
     *   redirectUrl: "https://your-app.com/callback", // optional
     *   // logoutRedirectUrl is optional - defaults to redirectUrl if not provided
     *   logoutRedirectUrl: "https://your-app.com/logout", // optional
     *   // oauthServerBaseUrl is optional - defaults to "https://auth.civic.com/oauth"
     *   oauthServerBaseUrl: "https://auth-server.com/", // optional
     *   // scopes is optional - defaults to ['openid', 'profile', 'email', 'offline_access']
     *   scopes: ["openid", "profile"], // optional
     *   targetContainerElement: "auth-container",
     *   textSignals: {
     *     success: "Authentication successful!"
     *   }
     * });
     * ```
     */
    static async create(config) {
        const instance = new CivicAuth(config);
        await instance.init();
        return instance;
    }
    /**
     * Initializes the auth client and checks for callback handling
     */
    async init() {
        this.logger.info("üöÄ Initializing CivicAuth", {
            currentUrl: window.location.href,
            redirectUrl: this.config.redirectUrl,
            oauthServerBaseUrl: this.config.oauthServerBaseUrl,
            isCallbackUrl: window.location.href.startsWith(this.config.redirectUrl),
        });
        try {
            // Get OAuth endpoints using shared function (handles trailing slash automatically)
            this.endpoints = await getOauthEndpoints(this.config.oauthServerBaseUrl);
            this.logger.info("üîó OAuth endpoints configured", {
                endpoints: this.endpoints,
            });
            // Initialize SessionManager with auth config
            if (this.sessionManager) {
                const authConfig = {
                    clientId: this.config.clientId,
                    redirectUrl: this.config.redirectUrl,
                    oauthServer: this.config.oauthServerBaseUrl,
                    scopes: this.config.scopes,
                    endpoints: this.endpoints,
                };
                this.logger.info("üîß Initializing SessionManager", { authConfig });
                await this.sessionManager.initializeWithAuthConfig(authConfig);
            }
            // Check if we're on the callback page
            const isCallbackPage = window.location.href.startsWith(this.config.redirectUrl);
            this.logger.info("üîç Callback page check", {
                isCallbackPage,
                currentUrl: window.location.href,
                redirectUrl: this.config.redirectUrl,
            });
            // Handle logout state cleanup first (before processing auth callbacks)
            await this.handleLogoutStateCleanup();
            if (isCallbackPage) {
                this.logger.info("üìû Processing callback page");
                await this.handleCallback();
            }
            else {
                this.logger.info("üè† Not a callback page, initialization complete");
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error
                ? error.message
                : "Failed to initialize authentication";
            this.logger.error("‚ùå CivicAuth initialization failed", {
                error: errorMessage,
                stack: error instanceof Error ? error.stack : undefined,
            });
            this.events.emit(AuthEvent.SIGN_IN_ERROR, {
                detail: errorMessage,
            });
            throw new CivicAuthError(errorMessage, CivicAuthErrorCode.INIT_FAILED);
        }
    }
    /**
     * Initialize all handlers with proper configuration
     */
    initializeHandlers() {
        const handlerConfig = {
            config: this.config,
            logger: this.logger,
            onAuthSuccess: this.handleAuthSuccess.bind(this),
            onAuthError: this.handleAuthError.bind(this),
            cleanup: this.cleanup.bind(this),
        };
        this.messageHandler = new MessageHandler({
            ...handlerConfig,
            onPopupFailure: this.handlePopupFailure.bind(this),
        });
        this.popupHandler = new PopupHandler(handlerConfig);
        this.iframeAuthHandler = new IframeAuthHandler({
            ...handlerConfig,
            messageHandler: this.messageHandler.handleMessage,
        });
    }
    /**
     * Builds the authentication URL with PKCE challenge
     */
    async buildAuthUrl() {
        if (!this.endpoints) {
            throw new CivicAuthError("OAuth endpoints not initialized. Please wait for initialization to complete.", CivicAuthErrorCode.ENDPOINTS_NOT_INITIALIZED);
        }
        const pkceProducer = new GenericPublicClientPKCEProducer(this.storage);
        const codeChallenge = await pkceProducer.getCodeChallenge();
        const state = this.config.initialState ||
            generateState({
                displayMode: this.config.displayMode || "iframe",
            });
        return buildAuthUrl({
            endpoints: this.endpoints,
            clientId: this.config.clientId,
            redirectUrl: this.config.redirectUrl,
            scopes: this.config.scopes,
            codeChallenge,
            state,
            prompt: this.config.prompt,
            nonce: this.config.nonce,
        });
    }
    /**
     * Starts the authentication process
     * @returns A promise that resolves with the authentication result
     * @throws {CivicAuthError} If authentication fails or times out
     */
    async startAuthentication() {
        this.logger.info("üé¨ Starting authentication process", {
            displayMode: this.config.displayMode,
            userAgent: navigator.userAgent,
            currentUrl: window.location.href,
        });
        if (!this.endpoints) {
            const error = new CivicAuthError("OAuth endpoints not initialized. Please wait for initialization to complete.", CivicAuthErrorCode.ENDPOINTS_NOT_INITIALIZED);
            this.logger.error("‚ùå Endpoints not initialized", {
                error: error.message,
            });
            this.events.emit(AuthEvent.SIGN_IN_ERROR, {
                detail: error.message,
            });
            throw error;
        }
        if (this.authPromise) {
            this.logger.info("‚è≥ Authentication already in progress, returning existing promise");
            return this.authPromise;
        }
        const fullAuthUrl = await this.buildAuthUrl();
        this.logger.info("üîó Built authentication URL", {
            url: fullAuthUrl,
            displayMode: this.config.displayMode,
            authProcessTimeout: this.config.authProcessTimeout,
        });
        this.authPromise = new Promise((resolve, reject) => {
            this.authPromiseResolve = resolve;
            this.authPromiseReject = reject;
            this.handleAuthenticationByDisplayMode(fullAuthUrl);
            this.setupAuthenticationTimeout();
        });
        return this.authPromise;
    }
    /**
     * Handle authentication based on display mode
     */
    async handleAuthenticationByDisplayMode(fullAuthUrl) {
        this.logger.info("üéØ Handling authentication with display mode", {
            displayMode: this.config.displayMode,
        });
        try {
            switch (this.config.displayMode) {
                case "redirect":
                    this.logger.info("üåê Using redirect mode");
                    window.location.href = fullAuthUrl;
                    break;
                case "new_tab":
                    this.logger.info("üì± Using new_tab mode");
                    if (!this.popupHandler) {
                        throw new Error("Popup handler not initialized");
                    }
                    await this.popupHandler.handleNewTabAuth(fullAuthUrl);
                    break;
                case "iframe":
                default: {
                    this.logger.info("üñºÔ∏è Using iframe mode");
                    if (!this.iframeAuthHandler || !this.messageHandler) {
                        throw new Error("Iframe handler not initialized");
                    }
                    const iframeElement = await this.iframeAuthHandler.handleIframeAuth(fullAuthUrl);
                    this.messageHandler.updateIframeElement(iframeElement);
                    break;
                }
            }
        }
        catch (error) {
            if (error instanceof PopupError) {
                await this.handlePopupErrorWithFallback(fullAuthUrl, error);
            }
            else {
                this.handleAuthError(error instanceof Error ? error : new Error(String(error)));
            }
        }
    }
    /**
     * Handle popup error with redirect fallback
     */
    async handlePopupErrorWithFallback(fullAuthUrl, error) {
        this.logger.warn("üö´ Popup failed, falling back to redirect mode", {
            originalDisplayMode: this.config.displayMode,
            error: error.message,
        });
        this.events.emit(AuthEvent.SIGN_IN_ERROR, {
            detail: "Popup blocked, falling back to redirect mode",
        });
        try {
            this.logger.info("üîÑ Attempting redirect fallback");
            // Clean up current authentication attempt
            this.cleanup();
            // Always switch to redirect mode for Safari compatibility
            this.config.displayMode = "redirect";
            // Regenerate the auth URL with updated display mode in state
            const fallbackAuthUrl = await this.buildAuthUrl();
            this.logger.info("üåê Redirecting to auth URL", { url: fallbackAuthUrl });
            window.location.href = fallbackAuthUrl;
            this.logger.info("‚úÖ Redirect initiated successfully");
        }
        catch (redirectError) {
            this.logger.error("‚ùå Redirect fallback failed", {
                error: redirectError,
                redirectUrl: fullAuthUrl,
            });
            const fallbackError = new CivicAuthError("Failed to open popup window and redirect fallback failed. Please check your browser's popup settings.", CivicAuthErrorCode.INIT_FAILED);
            this.events.emit(AuthEvent.SIGN_IN_ERROR, {
                detail: fallbackError.message,
            });
            this.handleAuthError(fallbackError);
        }
    }
    /**
     * Setup authentication timeout
     */
    setupAuthenticationTimeout() {
        // Skip timeout for embedded iframe mode - embedded iframes should stay persistent
        if (this.config.displayMode === "iframe" &&
            this.config.iframeDisplayMode === "embedded") {
            this.logger.debug("‚è∞ Skipping authentication timeout for embedded iframe mode", {
                displayMode: this.config.displayMode,
                iframeDisplayMode: this.config.iframeDisplayMode,
            });
            return;
        }
        if (this.config.authProcessTimeout && this.config.authProcessTimeout > 0) {
            this.logger.debug("‚è∞ Setting up authentication timeout", {
                authProcessTimeout: this.config.authProcessTimeout,
                displayMode: this.config.displayMode,
                iframeDisplayMode: this.config.iframeDisplayMode,
            });
            this.authProcessTimeoutHandle = window.setTimeout(() => {
                this.logger.error("‚è∞ Authentication timed out", {
                    displayMode: this.config.displayMode,
                    iframeDisplayMode: this.config.iframeDisplayMode,
                    currentOrigin: window.location.origin,
                    authProcessTimeout: this.config.authProcessTimeout,
                });
                this.events.emit(AuthEvent.SIGN_IN_ERROR, {
                    detail: "Authentication timed out",
                });
                const error = new CivicAuthError("Authentication timed out", CivicAuthErrorCode.AUTH_PROCESS_TIMEOUT);
                this.handleAuthError(error);
            }, this.config.authProcessTimeout);
        }
    }
    /**
     * Handle successful authentication
     */
    handleAuthSuccess(result) {
        this.logger.info("‚úÖ Authentication successful");
        this.authPromiseResolve?.(result);
        this.cleanup();
    }
    /**
     * Handle authentication error
     */
    handleAuthError(error) {
        this.logger.error("‚ùå Authentication failed", { error: error.message });
        this.authPromiseReject?.(error);
        this.cleanup();
    }
    /**
     * Handle popup failure - simplified like React implementation
     */
    handlePopupFailure(failedUrl) {
        this.hasPopupFailed = true;
        this.logger.warn("Popup failed, using redirect mode instead...", {
            failedUrl,
        });
        // Clean up iframe if it exists
        if (this.iframeAuthHandler) {
            this.iframeAuthHandler.cleanupIframe();
        }
        // Always redirect to the failed URL or build a new one
        if (failedUrl) {
            window.location.href = failedUrl;
        }
        else {
            this.buildAuthUrl()
                .then((authUrl) => {
                window.location.href = authUrl;
            })
                .catch((error) => {
                this.logger.error("Failed to build auth URL for redirect fallback", {
                    error,
                });
                const fallbackError = new CivicAuthError("Failed to redirect for authentication", CivicAuthErrorCode.INIT_FAILED);
                this.handleAuthError(fallbackError);
            });
        }
    }
    /**
     * Show popup failure message to user
     */
    showPopupFailureMessage(customMessage = "Authentication will continue in this window. Please wait...") {
        const container = this.getContainerElement();
        if (!container) {
            this.logger.warn("Cannot show popup failure message - container not found");
            return;
        }
        const existingMessage = document.getElementById("civic-auth-popup-failure-message");
        if (existingMessage && existingMessage.parentNode) {
            existingMessage.parentNode.removeChild(existingMessage);
        }
        const messageOverlay = document.createElement("div");
        messageOverlay.id = "civic-auth-popup-failure-message";
        messageOverlay.style.cssText =
            "position:absolute;top:0;left:0;right:0;background:rgba(255,249,196,.95);border:1px solid #f59e0b;border-radius:6px;padding:12px;margin:8px;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;font-size:14px;color:#92400e;z-index:1000;box-shadow:0 2px 4px rgba(0,0,0,.1);";
        messageOverlay.innerHTML =
            '<div style="display:flex;align-items:center;gap:8px;">' +
                '<span style="font-size:16px;">‚ö†Ô∏è</span>' +
                "<div>" +
                "<strong>Popup blocked</strong><br>" +
                '<span style="font-size:12px;">' +
                customMessage +
                "</span>" +
                "</div>" +
                "</div>";
        if (getComputedStyle(container).position === "static") {
            container.style.position = "relative";
        }
        container.appendChild(messageOverlay);
        setTimeout(() => {
            if (messageOverlay.parentNode) {
                messageOverlay.parentNode.removeChild(messageOverlay);
            }
        }, 10000);
        this.logger.info("Popup failure message displayed to user");
    }
    /**
     * Setup popup failure timeout
     */
    setupPopupFailureTimeout() {
        this.popupFailureTimeoutHandle = window.setTimeout(() => {
            this.logger.info("‚è∞ Popup failure timeout reached");
            this.events.emit(AuthEvent.SIGN_IN_ERROR, {
                detail: "Authentication timeout - popup failure scenario",
            });
            const error = new CivicAuthError("Authentication timeout - popup failure scenario", CivicAuthErrorCode.AUTH_PROCESS_TIMEOUT);
            this.handleAuthError(error);
        }, 20000); // 20 seconds
    }
    /**
     * Gets the container element for the auth iframe
     */
    getContainerElement() {
        if (typeof this.config.targetContainerElement === "string") {
            const element = document.getElementById(this.config.targetContainerElement);
            if (!element) {
                this.logger.warn(`Container element with ID "${this.config.targetContainerElement}" not found`);
            }
            return element;
        }
        return this.config.targetContainerElement ?? null;
    }
    /**
     * Handle OAuth callback
     */
    async handleCallback() {
        this.logger.info("üîÑ Handling OAuth callback", {
            currentUrl: window.location.href,
            redirectUrl: this.config.redirectUrl,
        });
        try {
            const callbackHandled = await handleOAuthRedirectPage({
                clientId: this.config.clientId,
                oauthServer: this.config.oauthServerBaseUrl,
                redirectUrl: this.config.redirectUrl,
                textSignals: {
                    success: this.config.textSignals.success,
                    error: this.config.textSignals.error || "Authentication failed",
                },
                storageAdapter: this.storage,
            });
            this.logger.info("üìã Callback processing result", { callbackHandled });
            if (callbackHandled) {
                const successSignal = document.getElementById(CIVIC_AUTH_CONSTANTS.SUCCESS_SIGNAL_ID);
                const errorSignal = document.getElementById(CIVIC_AUTH_CONSTANTS.ERROR_SIGNAL_ID);
                if (successSignal) {
                    this.logger.info("‚úÖ Success signal found");
                    let userInfo = null;
                    const userInfoAttr = successSignal.getAttribute("data-user-info");
                    if (userInfoAttr) {
                        try {
                            userInfo = JSON.parse(userInfoAttr);
                        }
                        catch (error) {
                            this.logger.error("‚ùå Failed to parse user info", { error });
                        }
                    }
                    this.events.emit(AuthEvent.SIGN_IN_COMPLETE, {
                        detail: "Callback processed successfully",
                        user: userInfo,
                    });
                }
                else if (errorSignal) {
                    this.logger.error("‚ùå Error signal found");
                    this.events.emit(AuthEvent.SIGN_IN_ERROR, {
                        detail: errorSignal.textContent || "Unknown error during callback",
                    });
                }
            }
        }
        catch (error) {
            this.logger.error("‚ùå Callback handling failed", { error });
            this.events.emit(AuthEvent.SIGN_IN_ERROR, {
                detail: error instanceof Error
                    ? error.message
                    : "Unknown error during callback",
            });
        }
    }
    /**
     * Cleans up resources and event listeners
     */
    cleanup() {
        this.logger.info("Cleaning up authentication client");
        // Clean up handlers
        this.iframeAuthHandler?.cleanupIframe();
        // Clean up timeouts
        if (this.authProcessTimeoutHandle) {
            window.clearTimeout(this.authProcessTimeoutHandle);
            this.authProcessTimeoutHandle = undefined;
        }
        if (this.popupFailureTimeoutHandle) {
            window.clearTimeout(this.popupFailureTimeoutHandle);
            this.popupFailureTimeoutHandle = undefined;
        }
        // Reset state
        this.hasPopupFailed = false;
        this.authPromise = undefined;
        this.authPromiseResolve = undefined;
        this.authPromiseReject = undefined;
        // Remove message event listener
        if (this.messageHandler) {
            window.removeEventListener("message", this.messageHandler.handleMessage);
        }
    }
    /**
     * Get the current session
     */
    async getCurrentSession() {
        return this.sessionManager.getCurrentSession() || null;
    }
    /**
     * Get current session tokens including decoded forwarded tokens
     * This method extracts and decodes forwarded tokens from the ID token JWT
     */
    async getTokensWithForwardedTokens() {
        const session = await this.getCurrentSession();
        return extractTokensFromSession(session);
    }
    /**
     * Check if user is authenticated
     */
    async isAuthenticated() {
        return this.sessionManager.isAuthenticated() || false;
    }
    /**
     * Get the current user
     */
    async getCurrentUser() {
        return this.sessionManager.getCurrentUser() || null;
    }
    /**
     * Clear the current session
     */
    async clearSession() {
        return this.sessionManager.clearSession();
    }
    /**
     * Manually refresh tokens
     */
    async refreshTokens() {
        return this.sessionManager.refreshTokens();
    }
    /**
     * Get token refresher state for debugging
     */
    getTokenRefresherState() {
        return this.sessionManager.getTokenRefresherState() || null;
    }
    /**
     * Update the iframe display mode
     * @param mode - The display mode to use for the iframe
     */
    setIframeDisplayMode(mode) {
        this.config.iframeDisplayMode = mode;
        this.logger.debug(`Iframe display mode updated to: ${mode}`);
    }
    /**
     * Get the current iframe display mode
     * @returns The current iframe display mode
     */
    getIframeDisplayMode() {
        return this.config.iframeDisplayMode;
    }
    /**
     * Destroy the auth client and clean up all resources
     */
    async destroy() {
        this.cleanup();
        await this.sessionManager.destroy();
        this.logger.info("CivicAuth destroyed");
    }
    /**
     * Handle logout
     */
    async logout() {
        try {
            this.logger.info("üîÑ Starting logout process");
            this.events.emit(AuthEvent.SIGN_OUT_STARTED, {
                detail: "Logout process started",
            });
            // Get current tokens before clearing them
            const tokens = await retrieveTokens(this.storage);
            if (!tokens?.id_token) {
                this.logger.warn("‚ö†Ô∏è No ID token found, clearing local session only");
                await clearTokens(this.storage);
                await this.sessionManager.clearSession();
                this.events.emit(AuthEvent.SIGN_OUT_COMPLETE, {
                    detail: "Local session cleared",
                });
                return;
            }
            if (!this.endpoints) {
                throw new Error("OAuth endpoints not initialized");
            }
            // Generate a state for logout
            const state = generateState({
                displayMode: this.config.displayMode || "iframe",
            });
            this.logger.info("üîÑ Storing logout state", {
                generatedState: state,
                logoutStateKey: LOGOUT_STATE,
                displayMode: this.config.displayMode,
            });
            // Store logout state for cleanup after redirect
            // This matches the React implementation - only store state for redirect flow
            await this.storage.set(LOGOUT_STATE, state);
            // Generate logout URL
            const logoutUrl = await generateOauthLogoutUrl({
                clientId: this.config.clientId,
                redirectUrl: this.config.logoutRedirectUrl,
                idToken: tokens.id_token,
                state: state,
                oauthServer: this.config.oauthServerBaseUrl,
            });
            this.logger.info("üîó Generated logout URL", {
                logoutUrl: logoutUrl.toString(),
            });
            // Clear local tokens and session but NOT the logout state (needed for cleanup after redirect)
            await this.sessionManager.clearSession(true); // preserveLogoutState = true
            // Emit logout complete event before redirect
            this.events.emit(AuthEvent.SIGN_OUT_COMPLETE, {
                detail: "Logout successful",
            });
            // Redirect to logout URL
            this.logger.info("üåê Redirecting to logout URL");
            window.location.href = logoutUrl.toString();
        }
        catch (error) {
            this.logger.error("‚ùå Logout failed", { error });
            this.events.emit(AuthEvent.SIGN_OUT_ERROR, {
                detail: error instanceof Error ? error.message : String(error),
            });
            throw new CivicAuthError("Logout failed", CivicAuthErrorCode.LOGOUT_FAILED);
        }
    }
    /**
     * Handle logout state cleanup
     * This mirrors the logic from useSignIn.ts to properly clean up after logout
     */
    async handleLogoutStateCleanup() {
        try {
            const params = new URLSearchParams(window.location.search);
            const state = params.get("state");
            this.logger.info("üîç Checking for logout state cleanup", {
                currentUrl: window.location.href,
                hasStateParam: !!state,
                stateValue: state,
                rawSearch: window.location.search,
            });
            if (!state) {
                this.logger.info("üîç No state parameter found, skipping logout cleanup");
                return; // No state parameter, nothing to cleanup
            }
            // Check if we have a stored logout state that matches
            const storedLogoutState = await this.storage.get(LOGOUT_STATE);
            // The state might be URL-decoded by URLSearchParams, but stored as plain
            // Let's try both the decoded and encoded versions
            const decodedState = decodeURIComponent(state);
            this.logger.info("üîç Comparing logout states", {
                urlState: state,
                decodedState,
                storedLogoutState,
                directMatch: state === storedLogoutState,
                decodedMatch: decodedState === storedLogoutState,
            });
            if (state === storedLogoutState || decodedState === storedLogoutState) {
                this.logger.info("üßπ Cleaning up logout state", {
                    state,
                    storedLogoutState,
                });
                // Clear tokens and user data from storage
                await clearTokens(this.storage);
                await this.sessionManager.clearSession();
                // Clean up the logout state from storage
                await this.storage.delete(LOGOUT_STATE);
                // Emit logout complete event
                this.events.emit(AuthEvent.SIGN_OUT_COMPLETE, {
                    detail: "Logout cleanup completed",
                });
                // Clean up URL by removing query parameters
                const cleanUrl = window.location.href.split("?")[0];
                window.history.replaceState({}, document.title, cleanUrl);
                this.logger.info("‚úÖ Logout state cleanup completed", {
                    cleanUrl,
                });
            }
            else {
                this.logger.info("üîç Logout states don't match, skipping cleanup", {
                    urlState: state,
                    storedLogoutState,
                });
            }
        }
        catch (error) {
            this.logger.warn("‚ö†Ô∏è Error during logout state cleanup", { error });
            // Don't throw error to prevent initialization failure
        }
    }
}
export { CivicAuthErrorCode } from "./types/AuthTypes.js";
//# sourceMappingURL=CivicAuth.js.map