import { AuthEvent } from "../types/index.js";
import { createLogger } from "../utils/logger.js";
import { TokenRefresher } from "./TokenRefresher.js";
import { retrieveTokens, clearTokens } from "../../shared/lib/util.js";
import { getUser } from "../../shared/lib/session.js";
import { GenericUserSession } from "../../shared/lib/UserSession.js";
export class SessionManager {
    storage;
    events;
    tokenRefresher;
    logger = createLogger("session");
    constructor(storageAdapter, events) {
        this.storage = storageAdapter;
        this.events = events;
        this.logger.info("SessionManager initialized with shared lib token storage");
    }
    /**
     * Initialize the session manager with auth configuration to enable token refresh
     */
    async initializeWithAuthConfig(authConfig) {
        try {
            // Initialize token refresher
            this.tokenRefresher = new TokenRefresher(this.storage, this.events, authConfig);
            await this.tokenRefresher.initialize(authConfig);
            // Set current authentication state
            const isAuthenticated = await this.isAuthenticated();
            this.tokenRefresher.setAuthenticationState(isAuthenticated);
            this.logger.info("SessionManager initialized with token refresh capability");
        }
        catch (error) {
            this.logger.error("Failed to initialize SessionManager with auth config:", error);
            this.events.emit(AuthEvent.TOKEN_REFRESH_ERROR, error);
        }
    }
    /**
     * Build current session from shared lib storage
     */
    async getCurrentSession() {
        try {
            const tokens = await retrieveTokens(this.storage);
            const user = await this.getCurrentUser();
            if (!tokens?.id_token || !user) {
                this.logger.warn("No id_token or user available, cannot create session");
                return null;
            }
            return {
                user,
                accessToken: tokens.access_token,
                idToken: tokens.id_token,
                refreshToken: tokens.refresh_token ?? undefined,
                expiresAt: tokens.oidc_session_expires_at ?? undefined,
            };
        }
        catch (error) {
            this.logger.error("Failed to load session from shared storage:", error);
            return null;
        }
    }
    /**
     * Check if user is authenticated using shared lib utilities
     */
    async isAuthenticated() {
        const tokens = await retrieveTokens(this.storage);
        return !!tokens?.id_token;
    }
    /**
     * Get current user from shared lib storage
     */
    async getCurrentUser() {
        try {
            return await getUser(this.storage);
        }
        catch (error) {
            this.logger.error("Failed to get user from shared storage:", error);
            return null;
        }
    }
    /**
     * Clear all authentication data using shared lib utilities
     * @param preserveLogoutState - If true, preserves logout state for cleanup after redirect
     */
    async clearSession(preserveLogoutState = false) {
        try {
            if (preserveLogoutState) {
                // During logout, we need to preserve logout state for cleanup after redirect
                await this.clearTokensExceptLogoutState();
            }
            else {
                // Normal session clearing - clear everything
                await clearTokens(this.storage);
            }
            // Clear user session using shared utilities
            const userSession = new GenericUserSession(this.storage);
            await userSession.clear();
            // Stop token refresher when session is cleared
            this.tokenRefresher?.setAuthenticationState(false);
            this.events.emit(AuthEvent.USER_SESSION_CHANGED, null);
            this.logger.info("Session cleared using shared lib utilities");
        }
        catch (error) {
            this.logger.error("Failed to clear session:", error);
            throw error;
        }
    }
    /**
     * Clear tokens from storage except logout state
     * This is needed during logout to preserve the logout state for cleanup after redirect
     */
    async clearTokensExceptLogoutState() {
        // Import constants
        const { REFRESH_IN_PROGRESS, AUTOREFRESH_TIMEOUT_NAME } = await import("../../constants.js");
        // Clear all token-related keys except LOGOUT_STATE
        // These are the OAuth token types from the constants
        const keysToDelete = [
            "id_token",
            "access_token",
            "refresh_token",
            "oidc_session_expires_at",
            REFRESH_IN_PROGRESS,
            AUTOREFRESH_TIMEOUT_NAME,
            // Note: NOT clearing LOGOUT_STATE here - it's needed for cleanup after redirect
        ];
        const clearPromises = keysToDelete.map(async (key) => {
            await this.storage.delete(key);
        });
        await Promise.all(clearPromises);
    }
    /**
     * Manually trigger token refresh
     */
    async refreshTokens() {
        if (!this.tokenRefresher) {
            throw new Error("Token refresher not initialized. Call initializeWithAuthConfig first.");
        }
        return this.tokenRefresher.refreshTokens();
    }
    /**
     * Get token refresher state for debugging
     */
    getTokenRefresherState() {
        return this.tokenRefresher?.getState() || null;
    }
    /**
     * Clean up resources when session manager is destroyed
     */
    async destroy() {
        await this.tokenRefresher?.destroy();
        this.tokenRefresher = undefined;
        this.logger.info("SessionManager destroyed");
    }
}
//# sourceMappingURL=SessionManager.js.map