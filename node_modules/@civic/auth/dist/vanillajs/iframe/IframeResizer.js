// Message types for communication between parent and child
import { createLogger } from "../utils/logger.js";
var MessageType;
(function (MessageType) {
    MessageType["RESIZE"] = "civic-iframe-resize";
    MessageType["READY"] = "civic-iframe-ready";
})(MessageType || (MessageType = {}));
export class CivicIframeResizer {
    iframe;
    container;
    logger;
    messageListener = null;
    requestSizeTimeouts = [];
    constructor(iframe, container) {
        this.iframe = iframe;
        this.container = container;
        this.logger = createLogger("iframe");
        this.initializeResizer();
    }
    initializeResizer() {
        this.logger.debug("Initializing Civic iframe resizer");
        // Set up message listener for iframe resize messages
        this.messageListener = (event) => {
            this.handleMessage(event);
        };
        window.addEventListener("message", this.messageListener);
        // Request size from child iframe after it loads
        this.iframe.addEventListener("load", () => {
            this.logger.debug("Iframe loaded, requesting size from child");
            this.requestSizeFromChild();
            // Schedule multiple size requests to ensure we get the correct height
            const intervals = [100, 500, 1000, 2000, 3000];
            intervals.forEach((interval) => {
                const timeoutId = window.setTimeout(() => {
                    this.requestSizeFromChild();
                }, interval);
                this.requestSizeTimeouts.push(timeoutId);
            });
        });
    }
    handleMessage(event) {
        try {
            const message = event.data;
            // Only handle messages from our iframe
            if (!this.iframe.contentWindow ||
                event.source !== this.iframe.contentWindow) {
                return;
            }
            this.logger.debug("Received message from iframe:", message);
            // Handle ready message
            if (message.type === MessageType.READY) {
                this.logger.debug("Iframe child is ready");
                this.requestSizeFromChild();
            }
            // Handle resize message
            if (message.type === MessageType.RESIZE &&
                typeof message.height === "number") {
                this.logger.debug("Resizing iframe to height:", message.height);
                this.resizeIframe(message.height, message.suggestedAnimationDuration);
            }
        }
        catch (error) {
            this.logger.debug("Error processing iframe message:", error);
        }
    }
    requestSizeFromChild() {
        if (this.iframe.contentWindow) {
            try {
                this.logger.debug("Requesting size from iframe child");
                this.iframe.contentWindow.postMessage({ type: "request-size" }, "*");
            }
            catch (error) {
                this.logger.debug("Error requesting size from iframe:", error);
            }
        }
    }
    resizeIframe(height, animationDuration) {
        // Ensure minimum height
        const minHeight = 200;
        const finalHeight = Math.max(height, minHeight);
        // Apply height to iframe and ensure no overflow
        this.iframe.style.height = `${finalHeight}px`;
        this.iframe.style.maxHeight = `${finalHeight}px`;
        this.iframe.style.overflow = "hidden";
        this.iframe.style.overflowX = "hidden";
        this.iframe.style.overflowY = "hidden";
        // Apply transition if animation duration is suggested
        if (animationDuration) {
            this.iframe.style.transition = `height ${animationDuration}ms ease`;
        }
        // Try to inject additional CSS to prevent scrollbars after resize
        try {
            const iframeDoc = this.iframe.contentDocument || this.iframe.contentWindow?.document;
            if (iframeDoc && iframeDoc.body) {
                iframeDoc.body.style.overflow = "hidden";
                iframeDoc.body.style.overflowX = "hidden";
                iframeDoc.body.style.overflowY = "hidden";
                if (iframeDoc.documentElement) {
                    iframeDoc.documentElement.style.overflow = "hidden";
                    iframeDoc.documentElement.style.overflowX = "hidden";
                    iframeDoc.documentElement.style.overflowY = "hidden";
                }
            }
        }
        catch (error) {
            this.logger.debug("Could not apply overflow styles to iframe content (likely cross-origin):", error);
        }
        this.logger.debug(`Iframe resized to ${finalHeight}px`);
    }
    cleanup() {
        this.logger.debug("Cleaning up iframe resizer");
        if (this.messageListener) {
            window.removeEventListener("message", this.messageListener);
            this.messageListener = null;
        }
        // Clear any pending timeouts
        this.requestSizeTimeouts.forEach((timeoutId) => {
            window.clearTimeout(timeoutId);
        });
        this.requestSizeTimeouts = [];
    }
    resize() {
        // Request size from child iframe
        this.requestSizeFromChild();
    }
}
//# sourceMappingURL=IframeResizer.js.map