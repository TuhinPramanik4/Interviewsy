import { AuthEvent } from "../types/index.js";
export class SignalObserver {
    config;
    observer;
    authPromiseResolve;
    authPromiseReject;
    cleanupCallback;
    constructor(config, authPromiseResolve, authPromiseReject, cleanupCallback) {
        this.config = config;
        this.authPromiseResolve = authPromiseResolve;
        this.authPromiseReject = authPromiseReject;
        this.cleanupCallback = cleanupCallback;
    }
    setup(iframeDoc) {
        this.config.logger.info("Setting up signal observer for iframe document");
        this.observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (!this.isRelevantMutation(mutation)) {
                    continue;
                }
                if (this.handleSignalNodes(iframeDoc)) {
                    return;
                }
                this.handleBodyTextSignals(iframeDoc);
            }
        });
        this.config.logger.debug("Starting observation of iframe body");
        this.observer.observe(iframeDoc.body, {
            childList: true,
            subtree: true,
            characterData: true,
        });
        // Check for initial signals
        this.handleInitialSignals(iframeDoc);
    }
    disconnect() {
        if (this.observer) {
            this.config.logger.debug("Disconnecting mutation observer");
            this.observer.disconnect();
            this.observer = undefined;
        }
    }
    isRelevantMutation(mutation) {
        return mutation.type === "childList" || mutation.type === "characterData";
    }
    handleSignalNodes(iframeDoc) {
        const successNode = iframeDoc.getElementById("civic-auth-success-signal");
        const errorNode = iframeDoc.getElementById("civic-auth-error-signal");
        if (this.handleSuccessNode(successNode)) {
            return true;
        }
        if (this.handleErrorNode(errorNode)) {
            return true;
        }
        return false;
    }
    handleSuccessNode(successNode) {
        if (successNode?.textContent !== this.config.textSignals.success) {
            return false;
        }
        this.config.logger.info("Success signal detected in iframe by ID");
        const userInfo = this.parseUserInfo(successNode);
        this.config.events?.emit(AuthEvent.SIGN_IN_COMPLETE, {
            detail: "Success signal detected in iframe",
            user: userInfo,
        });
        this.authPromiseResolve?.({
            user: userInfo,
            signalText: successNode.textContent,
        });
        this.cleanup();
        return true;
    }
    handleErrorNode(errorNode) {
        if (!errorNode) {
            return false;
        }
        this.config.logger.warn("Error signal detected in iframe by ID");
        const errorMessage = errorNode.textContent || "Error signal detected in iframe";
        this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
            detail: errorMessage,
        });
        this.authPromiseReject?.(new Error(errorMessage));
        this.cleanup();
        return true;
    }
    handleBodyTextSignals(iframeDoc) {
        const bodyText = iframeDoc.body?.textContent || "";
        this.config.logger.debug("Checking iframe body text for signals (fallback)", { bodyText });
        if (this.handleBodySuccessSignal(bodyText)) {
            return;
        }
        this.handleBodyErrorSignal(bodyText);
    }
    handleBodySuccessSignal(bodyText) {
        if (!bodyText.includes(this.config.textSignals.success)) {
            return false;
        }
        this.config.logger.info("Success signal detected in iframe by text content (fallback)");
        this.config.events?.emit(AuthEvent.SIGN_IN_COMPLETE, {
            detail: "Success signal detected in iframe (text fallback)",
        });
        this.authPromiseResolve?.({
            signalText: this.config.textSignals.success,
        });
        this.cleanup();
        return true;
    }
    handleBodyErrorSignal(bodyText) {
        if (!this.config.textSignals.error ||
            !bodyText.includes(this.config.textSignals.error)) {
            return false;
        }
        this.config.logger.warn("Error signal detected in iframe by text content (fallback)");
        this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
            detail: this.config.textSignals.error,
        });
        this.authPromiseReject?.(new Error(this.config.textSignals.error));
        this.cleanup();
        return true;
    }
    parseUserInfo(node) {
        const userInfoAttr = node.getAttribute("data-user-info");
        if (!userInfoAttr) {
            return undefined;
        }
        try {
            const parsed = JSON.parse(userInfoAttr);
            // Ensure we have at least an id field
            if (!parsed.id || typeof parsed.id !== "string") {
                this.config.logger.error("User info missing required 'id' field");
                return undefined;
            }
            return parsed;
        }
        catch (parseError) {
            this.config.logger.error("Failed to parse user info:", {
                error: parseError,
            });
            return undefined;
        }
    }
    handleInitialSignals(iframeDoc) {
        const successNode = iframeDoc.getElementById("civic-auth-success-signal");
        const errorNode = iframeDoc.getElementById("civic-auth-error-signal");
        if (this.handleSuccessNode(successNode) ||
            this.handleErrorNode(errorNode)) {
            return;
        }
        const initialBodyText = iframeDoc.body?.textContent || "";
        this.config.logger.debug("Performing initial signal check by text (fallback)", { initialBodyText });
        if (this.handleBodySuccessSignal(initialBodyText) ||
            this.handleBodyErrorSignal(initialBodyText)) {
            return;
        }
    }
    cleanup() {
        this.disconnect();
        this.cleanupCallback?.();
    }
}
//# sourceMappingURL=SignalObserver.js.map