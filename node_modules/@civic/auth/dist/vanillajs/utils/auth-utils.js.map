{"version":3,"file":"auth-utils.js","sourceRoot":"","sources":["../../../src/vanillajs/utils/auth-utils.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,SAAS,EAAE,MAAM,MAAM,CAAC;AACjC,OAAO,EAAE,2BAA2B,EAAE,MAAM,kBAAkB,CAAC;AAa/D,MAAM,UAAU,YAAY,CAAC,EAC3B,SAAS,EACT,QAAQ,EACR,WAAW,EACX,MAAM,EACN,aAAa,EACb,KAAK,EACL,MAAM,EACN,KAAK,GACc;IACnB,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACxC,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IACnD,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;IACzD,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;IACrD,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IACvD,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IAC5C,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,gBAAgB,EAAE,aAAa,CAAC,CAAC;IAC7D,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,uBAAuB,EAAE,MAAM,CAAC,CAAC;IAE7D,uDAAuD;IACvD,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,CAAC;IAE3D,IAAI,KAAK,EAAE,CAAC;QACV,uDAAuD;QACvD,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IAC9C,CAAC;IAED,OAAO,OAAO,CAAC,QAAQ,EAAE,CAAC;AAC5B,CAAC;AASD;;;;GAIG;AACH,MAAM,UAAU,wBAAwB,CACtC,OAAuB;IAEvB,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,OAAO;YACL,OAAO,EAAE,IAAI;YACb,WAAW,EAAE,IAAI;YACjB,YAAY,EAAE,IAAI;YAClB,eAAe,EAAE,SAAS;SAC3B,CAAC;IACJ,CAAC;IAED,MAAM,EAAE,OAAO,EAAE,WAAW,EAAE,YAAY,EAAE,GAAG,OAAO,CAAC;IAEvD,iEAAiE;IACjE,MAAM,eAAe,GAAG,OAAO;QAC7B,CAAC,CAAC,CAAC,GAAG,EAAE;YACJ,IAAI,CAAC;gBACH,MAAM,EAAE,eAAe,EAAE,kBAAkB,EAAE,GAAG,SAAS,CACvD,OAAO,CACU,CAAC;gBACpB,IAAI,CAAC,kBAAkB;oBAAE,OAAO,SAAS,CAAC;gBAC1C,OAAO,2BAA2B,CAAC,kBAAkB,CAAC,CAAC;YACzD,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACb,OAAO,CAAC,IAAI,CAAC,kDAAkD,EAAE,GAAG,CAAC,CAAC;gBACtE,OAAO,SAAS,CAAC;YACnB,CAAC;QACH,CAAC,CAAC,EAAE;QACN,CAAC,CAAC,SAAS,CAAC;IAEd,OAAO;QACL,OAAO,EAAE,OAAO,IAAI,IAAI;QACxB,WAAW,EAAE,WAAW,IAAI,IAAI;QAChC,YAAY,EAAE,YAAY,IAAI,IAAI;QAClC,eAAe;KAChB,CAAC;AACJ,CAAC","sourcesContent":["import type { Endpoints } from \"../../types.js\";\nimport type { Session } from \"../types/index.js\";\nimport type { ForwardedTokens, IdTokenPayload } from \"../../types.js\";\nimport { decodeJwt } from \"jose\";\nimport { convertForwardedTokenFormat } from \"../../lib/jwt.js\";\n\ninterface BuildAuthUrlParams {\n  endpoints: Endpoints;\n  clientId: string;\n  redirectUrl: string;\n  scopes: string[];\n  codeChallenge: string;\n  state: string;\n  prompt?: string;\n  nonce?: string;\n}\n\nexport function buildAuthUrl({\n  endpoints,\n  clientId,\n  redirectUrl,\n  scopes,\n  codeChallenge,\n  state,\n  prompt,\n  nonce,\n}: BuildAuthUrlParams): string {\n  const authUrl = new URL(endpoints.auth);\n  authUrl.searchParams.append(\"client_id\", clientId);\n  authUrl.searchParams.append(\"redirect_uri\", redirectUrl);\n  authUrl.searchParams.append(\"response_type\", \"code\");\n  authUrl.searchParams.append(\"scope\", scopes.join(\" \"));\n  authUrl.searchParams.append(\"state\", state);\n  authUrl.searchParams.append(\"code_challenge\", codeChallenge);\n  authUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n\n  // Required by the auth server for offline_access scope\n  authUrl.searchParams.append(\"prompt\", prompt || \"consent\");\n\n  if (nonce) {\n    // nonce isn't supported by oslo, so we add it manually\n    authUrl.searchParams.append(\"nonce\", nonce);\n  }\n\n  return authUrl.toString();\n}\n\nexport interface ExtractedTokens {\n  idToken: string | null;\n  accessToken: string | null;\n  refreshToken: string | null;\n  forwardedTokens?: ForwardedTokens;\n}\n\n/**\n * Extracts all tokens including decoded forwarded tokens from a session\n * This utility handles JWT decoding and token format conversion at the vanilla JS layer\n * making it available to both vanilla JS and React consumers\n */\nexport function extractTokensFromSession(\n  session: Session | null,\n): ExtractedTokens {\n  if (!session) {\n    return {\n      idToken: null,\n      accessToken: null,\n      refreshToken: null,\n      forwardedTokens: undefined,\n    };\n  }\n\n  const { idToken, accessToken, refreshToken } = session;\n\n  // Extract forwardedTokens from ID token (only if idToken exists)\n  const forwardedTokens = idToken\n    ? (() => {\n        try {\n          const { forwardedTokens: jwtForwardedTokens } = decodeJwt(\n            idToken,\n          ) as IdTokenPayload;\n          if (!jwtForwardedTokens) return undefined;\n          return convertForwardedTokenFormat(jwtForwardedTokens);\n        } catch (err) {\n          console.warn(\"Failed to decode forwarded tokens from ID token:\", err);\n          return undefined;\n        }\n      })()\n    : undefined;\n\n  return {\n    idToken: idToken || null,\n    accessToken: accessToken || null,\n    refreshToken: refreshToken || null,\n    forwardedTokens,\n  };\n}\n"]}